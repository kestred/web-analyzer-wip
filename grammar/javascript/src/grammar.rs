// This file is automatically generated by running `cargo run -p antlr_codegen`.
//
// =====================
// Do not edit manually.
// =====================
//
#![allow(dead_code)]
#![allow(unused_imports)]

//! This module contains an auto-generated JAVASCRIPT parser.
use crate::grammar_ext;
use crate::syntax_kind::*;
use grammar_utils::{catch, tokenset, Parser, TokenSet};
use grammar_utils::parser::Continue;

pub fn program(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if p.at_ts(&_TS0) || (!p.at(L_CURLY) && !p.at(FUNCTION_KW) && p.at_ts(&_TS1)) {
            source_elements(p)?;
        }
        p.expect(EOF)?;
        Some(Continue)
    });
    p.complete(_marker, PROGRAM);
    _ok
}

pub fn source_element(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&_TS2) || (!p.at(L_CURLY) && !p.at(FUNCTION_KW) && p.at_ts(&_TS1)) {
        statement(p)?;
    } else if p.at_ts(&tokenset![EXPORT_KW, IMPORT_KW]) {
        module_declaration(p)?;
    } else {
        p.expected_ts_in("source_element", &AT_SOURCE_ELEMENT)?;
    }
    Some(Continue)
}

pub fn module_declaration(p: &mut Parser) -> Option<Continue> {
    if p.at(IMPORT_KW) {
        import_declaration(p)?;
    } else if p.at(EXPORT_KW) {
        export_declaration(p)?;
    } else {
        p.expected_ts_in("module_declaration", &tokenset![EXPORT_KW, IMPORT_KW])?;
    }
    Some(Continue)
}

pub fn export_declaration(p: &mut Parser) -> Option<Continue> {
    let mut _checkpoint = p.checkpoint(false);
    let _marker = p.start();
    p.expect(EXPORT_KW)?;
    if p.at(L_CURLY) {
        p.bump();
        export_specifier_list(p)?;
        p.expect(R_CURLY)?;
        if p.at_keyword("from") && p.at(IDENTIFIER) {
            from_kw(p)?;
            if !(p.at(STRING_LITERAL)) {
                p.error("expected input to be at STRING_LITERAL")?;
            }
            literal(p)?;
        }
        p.complete(_checkpoint.branch(&_marker), EXPORT_NAMED_DECLARATION);
    } else if p.at_ts(&tokenset![CONST_KW, LET_KW, VAR_KW]) {
        variable_declaration(p)?;
        p.complete(_checkpoint.branch(&_marker), EXPORT_NAMED_DECLARATION);
    } else if p.at(DEFAULT_KW) && {
        // try --> DEFAULT_KW class_declaration #EXPORT_DEFAULT_DECLARATION
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            p.bump();
            class_declaration(p)?;
            p.complete(_checkpoint.branch(&_marker), EXPORT_DEFAULT_DECLARATION);
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(DEFAULT_KW) && {
        // try --> DEFAULT_KW function_declaration #EXPORT_DEFAULT_DECLARATION
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            p.bump();
            function_declaration(p)?;
            p.complete(_checkpoint.branch(&_marker), EXPORT_DEFAULT_DECLARATION);
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(DEFAULT_KW) {
        p.bump();
        expression(p)?;
        eos(p)?;
        p.complete(_checkpoint.branch(&_marker), EXPORT_DEFAULT_DECLARATION);
    } else if p.at(ASTERISK) {
        p.bump();
        from_kw(p)?;
        if !(p.at(STRING_LITERAL)) {
            p.error("expected input to be at STRING_LITERAL")?;
        }
        literal(p)?;
        p.complete(_checkpoint.branch(&_marker), EXPORT_ALL_DECLARATION);
    } else {
        // otherwise, emit an error
        p.expected_ts_in("export_declaration", &_TS3)?;
    }
    Some(Continue)
}

pub fn export_specifier_list(p: &mut Parser) -> Option<Continue> {
    export_specifier_atom(p)?;
    while p.at(COMMA) {
        p.bump();
        export_specifier_atom(p)?;
    }
    Some(Continue)
}

pub fn export_specifier_atom(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(IDENTIFIER)?;
        as_kw(p)?;
        p.expect(IDENTIFIER)?;
        Some(Continue)
    });
    p.complete(_marker, EXPORT_SPECIFIER);
    _ok
}

pub fn import_declaration(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(IMPORT_KW)?;
        import_declaration_list(p)?;
        from_kw(p)?;
        if !(p.at(STRING_LITERAL)) {
            p.error("expected input to be at STRING_LITERAL")?;
        }
        literal(p)?;
        Some(Continue)
    });
    p.complete(_marker, IMPORT_DECLARATION);
    _ok
}

pub fn import_declaration_list(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&tokenset![ASTERISK, IDENTIFIER]) && {
        // try --> import_specifier_special
        let mut _checkpoint = p.checkpoint(true);
        import_specifier_special(p);
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at_ts(&tokenset![ASTERISK, IDENTIFIER]) {
        import_specifier_special(p)?;
        p.expect(COMMA)?;
        p.expect(L_CURLY)?;
        import_specifier_list(p)?;
        p.expect(R_CURLY)?;
    } else if p.at(L_CURLY) {
        p.bump();
        import_specifier_list(p)?;
        p.expect(R_CURLY)?;
    } else {
        // otherwise, emit an error
        p.expected_ts_in("import_declaration_list", &tokenset![ASTERISK, IDENTIFIER, L_CURLY])?;
    }
    Some(Continue)
}

pub fn import_specifier_list(p: &mut Parser) -> Option<Continue> {
    import_specifier_atom(p)?;
    while p.at(COMMA) {
        p.bump();
        import_specifier_atom(p)?;
    }
    Some(Continue)
}

pub fn import_specifier_atom(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(IDENTIFIER)?;
        as_kw(p)?;
        p.expect(IDENTIFIER)?;
        Some(Continue)
    });
    p.complete(_marker, IMPORT_SPECIFIER);
    _ok
}

pub fn import_specifier_special(p: &mut Parser) -> Option<Continue> {
    if p.at(IDENTIFIER) {
        let _marker = p.start();
        p.bump();
        p.complete(_marker, IMPORT_DEFAULT_SPECIFIER);
    } else if p.at(ASTERISK) {
        let _marker = p.start();
        let _ok = catch!({
            p.bump();
            as_kw(p)?;
            p.expect(IDENTIFIER)?;
            Some(Continue)
        });
        p.complete(_marker, IMPORT_NAMESPACE_SPECIFIER);
        if _ok.is_none() {
            return None;
        }
    } else {
        p.expected_ts_in("import_specifier_special", &tokenset![ASTERISK, IDENTIFIER])?;
    }
    Some(Continue)
}

pub fn statement(p: &mut Parser) -> Option<Continue> {
    if p.at(L_CURLY) && {
        // try --> block
        let mut _checkpoint = p.checkpoint(true);
        block(p);
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(SEMICOLON) {
        empty_statement(p)?;
    } else if p.at(IF_KW) {
        if_statement(p)?;
    } else if p.at(FOR_KW) {
        for_statement(p)?;
    } else if p.at(WHILE_KW) {
        while_statement(p)?;
    } else if p.at(DO_KW) {
        do_while_statement(p)?;
    } else if p.at(CONTINUE_KW) {
        continue_statement(p)?;
    } else if p.at(BREAK_KW) {
        break_statement(p)?;
    } else if p.at(RETURN_KW) {
        return_statement(p)?;
    } else if p.at(WITH_KW) {
        with_statement(p)?;
    } else if p.at(SWITCH_KW) {
        switch_statement(p)?;
    } else if p.at(THROW_KW) {
        throw_statement(p)?;
    } else if p.at(TRY_KW) {
        try_statement(p)?;
    } else if p.at(DEBUGGER_KW) {
        debugger_statement(p)?;
    } else if p.at(CLASS_KW) && {
        // try --> class_declaration
        let mut _checkpoint = p.checkpoint(true);
        class_declaration(p);
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at_ts(&tokenset![CONST_KW, LET_KW, VAR_KW]) {
        variable_declaration(p)?;
        eos(p)?;
    } else if p.at(FUNCTION_KW) && {
        // try --> function_declaration
        let mut _checkpoint = p.checkpoint(true);
        function_declaration(p);
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if (!p.at(L_CURLY) && !p.at(FUNCTION_KW) && p.at_ts(&AT_EXPRESSION)) && {
        // try --> expression_statement
        let mut _checkpoint = p.checkpoint(true);
        expression_statement(p);
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(IDENTIFIER) {
        labeled_statement(p)?;
    } else {
        // otherwise, emit an error
        p.expected_ts_in("statement", &AT_STATEMENT)?;
    }
    Some(Continue)
}

pub fn block(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_CURLY)?;
        if p.at_ts(&_TS2) || (!p.at(L_CURLY) && !p.at(FUNCTION_KW) && p.at_ts(&_TS1)) {
            statement_list(p)?;
        }
        p.expect(R_CURLY)?;
        Some(Continue)
    });
    p.complete(_marker, BLOCK_STATEMENT);
    _ok
}

pub fn statement_list(p: &mut Parser) -> Option<Continue> {
    loop {
        statement(p)?;
        if !(p.at_ts(&_TS2) || (!p.at(L_CURLY) && !p.at(FUNCTION_KW) && p.at_ts(&_TS1))) { break }
    }
    Some(Continue)
}

pub fn variable_declaration(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        variable_declaration_kind(p)?;
        variable_declarator_list(p)?;
        Some(Continue)
    });
    p.complete(_marker, VARIABLE_DECLARATION);
    _ok
}

pub fn variable_declaration_kind(p: &mut Parser) -> Option<Continue> {
    p.expect_ts(&tokenset![CONST_KW, LET_KW, VAR_KW])
}

pub fn variable_declarator_list(p: &mut Parser) -> Option<Continue> {
    variable_declarator(p)?;
    while p.at(COMMA) {
        p.bump();
        variable_declarator(p)?;
    }
    Some(Continue)
}

pub fn variable_declarator(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if p.at(IDENTIFIER) {
            p.bump();
        } else if p.at(L_SQUARE) {
            array_expression(p)?;
        } else if p.at(L_CURLY) {
            object_expression(p)?;
        } else {
            p.expected_ts_in("variable_declarator", &tokenset![IDENTIFIER, L_CURLY, L_SQUARE])?;
        }
        if p.at(EQ) {
            p.bump();
            expression(p)?;
        }
        Some(Continue)
    });
    p.complete(_marker, VARIABLE_DECLARATOR);
    _ok
}

pub fn empty_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = p.expect(SEMICOLON);
    p.complete(_marker, EMPTY_STATEMENT);
    _ok
}

pub fn expression_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if !(!p.at(L_CURLY) && !p.at(FUNCTION_KW)) {
            p.error("expected input to be not at L_CURLY and not at FUNCTION_KW")?;
        }
        expression_sequence(p)?;
        eos(p)?;
        Some(Continue)
    });
    p.complete(_marker, EXPRESSION_STATEMENT);
    _ok
}

pub fn if_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(IF_KW)?;
        p.expect(L_PAREN)?;
        expression_sequence(p)?;
        p.expect(R_PAREN)?;
        statement(p)?;
        if p.at(ELSE_KW) {
            p.bump();
            statement(p)?;
        }
        Some(Continue)
    });
    p.complete(_marker, IF_STATEMENT);
    _ok
}

pub fn for_statement(p: &mut Parser) -> Option<Continue> {
    let mut _checkpoint = p.checkpoint(false);
    let _marker = p.start();
    p.expect(FOR_KW)?;
    p.expect(L_PAREN)?;
    if p.at_ts(&_TS4) && {
        // try --> (expression_sequence)? ; (expression_sequence)? ; (expression_sequence)? ) statement_list #FOR_STATEMENT
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            if p.at_ts(&AT_EXPRESSION) {
                expression_sequence(p)?;
            }
            p.expect(SEMICOLON)?;
            if p.at_ts(&AT_EXPRESSION) {
                expression_sequence(p)?;
            }
            p.expect(SEMICOLON)?;
            if p.at_ts(&AT_EXPRESSION) {
                expression_sequence(p)?;
            }
            p.expect(R_PAREN)?;
            statement_list(p)?;
            p.complete(_checkpoint.branch(&_marker), FOR_STATEMENT);
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at_ts(&tokenset![CONST_KW, LET_KW, VAR_KW]) && {
        // try --> variable_declaration ; (expression_sequence)? ; (expression_sequence)? ) statement #FOR_STATEMENT
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            variable_declaration(p)?;
            p.expect(SEMICOLON)?;
            if p.at_ts(&AT_EXPRESSION) {
                expression_sequence(p)?;
            }
            p.expect(SEMICOLON)?;
            if p.at_ts(&AT_EXPRESSION) {
                expression_sequence(p)?;
            }
            p.expect(R_PAREN)?;
            statement(p)?;
            p.complete(_checkpoint.branch(&_marker), FOR_STATEMENT);
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at_ts(&AT_EXPRESSION) && {
        // try --> expression IN_KW expression ) statement_list #FOR_IN_STATEMENT
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            expression(p)?;
            p.expect(IN_KW)?;
            expression(p)?;
            p.expect(R_PAREN)?;
            statement_list(p)?;
            p.complete(_checkpoint.branch(&_marker), FOR_IN_STATEMENT);
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at_ts(&tokenset![CONST_KW, LET_KW, VAR_KW]) && {
        // try --> variable_declaration IN_KW expression ) statement #FOR_IN_STATEMENT
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            variable_declaration(p)?;
            p.expect(IN_KW)?;
            expression(p)?;
            p.expect(R_PAREN)?;
            statement(p)?;
            p.complete(_checkpoint.branch(&_marker), FOR_IN_STATEMENT);
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at_ts(&AT_EXPRESSION) {
        expression(p)?;
        of_kw(p)?;
        expression(p)?;
        p.expect(R_PAREN)?;
        statement_list(p)?;
        p.complete(_checkpoint.branch(&_marker), FOR_OF_STATEMENT);
    } else if p.at_ts(&tokenset![CONST_KW, LET_KW, VAR_KW]) {
        variable_declaration(p)?;
        of_kw(p)?;
        expression(p)?;
        p.expect(R_PAREN)?;
        statement(p)?;
        p.complete(_checkpoint.branch(&_marker), FOR_OF_STATEMENT);
    } else {
        // otherwise, emit an error
        p.expected_ts_in("for_statement", &_TS5)?;
    }
    Some(Continue)
}

pub fn while_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(WHILE_KW)?;
        p.expect(L_PAREN)?;
        expression_sequence(p)?;
        p.expect(R_PAREN)?;
        statement(p)?;
        Some(Continue)
    });
    p.complete(_marker, WHILE_STATEMENT);
    _ok
}

pub fn do_while_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(DO_KW)?;
        statement(p)?;
        p.expect(WHILE_KW)?;
        p.expect(L_PAREN)?;
        expression_sequence(p)?;
        p.expect(R_PAREN)?;
        eos(p)?;
        Some(Continue)
    });
    p.complete(_marker, DO_WHILE_STATEMENT);
    _ok
}

pub fn continue_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(CONTINUE_KW)?;
        if !p.at_line_terminator() && p.at(IDENTIFIER) {
            p.bump();
        }
        eos(p)?;
        Some(Continue)
    });
    p.complete(_marker, CONTINUE_STATEMENT);
    _ok
}

pub fn break_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(BREAK_KW)?;
        if !p.at_line_terminator() && p.at(IDENTIFIER) {
            p.bump();
        }
        eos(p)?;
        Some(Continue)
    });
    p.complete(_marker, BREAK_STATEMENT);
    _ok
}

pub fn return_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(RETURN_KW)?;
        if !p.at_line_terminator() && p.at_ts(&AT_EXPRESSION) {
            expression_sequence(p)?;
        }
        eos(p)?;
        Some(Continue)
    });
    p.complete(_marker, RETURN_STATEMENT);
    _ok
}

pub fn with_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(WITH_KW)?;
        p.expect(L_PAREN)?;
        expression_sequence(p)?;
        p.expect(R_PAREN)?;
        statement(p)?;
        Some(Continue)
    });
    p.complete(_marker, WITH_STATEMENT);
    _ok
}

pub fn switch_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(SWITCH_KW)?;
        p.expect(L_PAREN)?;
        expression_sequence(p)?;
        p.expect(R_PAREN)?;
        case_block(p)?;
        Some(Continue)
    });
    p.complete(_marker, SWITCH_STATEMENT);
    _ok
}

pub fn case_block(p: &mut Parser) -> Option<Continue> {
    p.expect(L_CURLY)?;
    if p.at(CASE_KW) {
        case_clauses(p)?;
    }
    if p.at(DEFAULT_KW) {
        default_clause(p)?;
        if p.at(CASE_KW) {
            case_clauses(p)?;
        }
    }
    p.expect(R_CURLY)?;
    Some(Continue)
}

pub fn case_clauses(p: &mut Parser) -> Option<Continue> {
    loop {
        case_clause(p)?;
        if !p.at(CASE_KW) { break }
    }
    Some(Continue)
}

pub fn case_clause(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(CASE_KW)?;
        expression_sequence(p)?;
        p.expect(COLON)?;
        if p.at_ts(&_TS2) || (!p.at(L_CURLY) && !p.at(FUNCTION_KW) && p.at_ts(&_TS1)) {
            statement_list(p)?;
        }
        Some(Continue)
    });
    p.complete(_marker, SWITCH_CASE);
    _ok
}

pub fn default_clause(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(DEFAULT_KW)?;
        p.expect(COLON)?;
        if p.at_ts(&_TS2) || (!p.at(L_CURLY) && !p.at(FUNCTION_KW) && p.at_ts(&_TS1)) {
            statement_list(p)?;
        }
        Some(Continue)
    });
    p.complete(_marker, SWITCH_CASE);
    _ok
}

pub fn labeled_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(IDENTIFIER)?;
        p.expect(COLON)?;
        statement(p)?;
        Some(Continue)
    });
    p.complete(_marker, LABELED_STATEMENT);
    _ok
}

pub fn throw_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(THROW_KW)?;
        if !(!p.at_line_terminator()) {
            p.error("expected input to be not at line terminator")?;
        }
        expression_sequence(p)?;
        eos(p)?;
        Some(Continue)
    });
    p.complete(_marker, THROW_STATEMENT);
    _ok
}

pub fn try_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(TRY_KW)?;
        block(p)?;
        if p.at(CATCH_KW) {
            catch_clause(p)?;
            if p.at(FINALLY_KW) {
                finally_clause(p)?;
            }
        } else if p.at(FINALLY_KW) {
            finally_clause(p)?;
        } else {
            p.expected_ts_in("try_statement", &tokenset![CATCH_KW, FINALLY_KW])?;
        }
        Some(Continue)
    });
    p.complete(_marker, TRY_STATEMENT);
    _ok
}

pub fn catch_clause(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(CATCH_KW)?;
        p.expect(L_PAREN)?;
        p.expect(IDENTIFIER)?;
        p.expect(R_PAREN)?;
        block(p)?;
        Some(Continue)
    });
    p.complete(_marker, CATCH_CLAUSE);
    _ok
}

pub fn finally_clause(p: &mut Parser) -> Option<Continue> {
    p.expect(FINALLY_KW)?;
    block(p)?;
    Some(Continue)
}

pub fn debugger_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(DEBUGGER_KW)?;
        eos(p)?;
        Some(Continue)
    });
    p.complete(_marker, DEBUGGER_STATEMENT);
    _ok
}

pub fn function_declaration(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(FUNCTION_KW)?;
        p.eat(ASTERISK);
        p.expect(IDENTIFIER)?;
        p.expect(L_PAREN)?;
        if p.at_ts(&tokenset![DOTDOTDOT, IDENTIFIER, L_CURLY, L_SQUARE]) {
            formal_parameter_list(p)?;
        }
        p.expect(R_PAREN)?;
        function_body(p)?;
        Some(Continue)
    });
    p.complete(_marker, FUNCTION_DECLARATION);
    _ok
}

pub fn class_declaration(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(CLASS_KW)?;
        p.expect(IDENTIFIER)?;
        class_tail(p)?;
        Some(Continue)
    });
    p.complete(_marker, CLASS_DECLARATION);
    _ok
}

pub fn class_tail(p: &mut Parser) -> Option<Continue> {
    if p.at(EXTENDS_KW) {
        p.bump();
        expression(p)?;
    }
    class_body(p)?;
    Some(Continue)
}

pub fn class_body(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_CURLY)?;
        while p.at_ts(&AT_CLASS_ELEMENT) {
            class_element(p)?;
        }
        p.expect(R_CURLY)?;
        Some(Continue)
    });
    p.complete(_marker, CLASS_BODY);
    _ok
}

pub fn class_element(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&AT_METHOD_DEFINITION) {
        method_definition(p)?;
    } else if p.at(SEMICOLON) {
        empty_statement(p)?;
    } else {
        p.expected_ts_in("class_element", &AT_CLASS_ELEMENT)?;
    }
    Some(Continue)
}

pub fn method_definition(p: &mut Parser) -> Option<Continue> {
    let mut _checkpoint = p.checkpoint(false);
    let _marker = p.start();
    p.eat(STATIC_KW);
    if p.at_ts(&AT_PROPERTY_NAME) && {
        // try --> property_name method_tail #METHOD_DEFINITION
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            property_name(p)?;
            method_tail(p)?;
            p.complete(_checkpoint.branch(&_marker), METHOD_DEFINITION);
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if (p.at_keyword("get") && p.at(IDENTIFIER)) && {
        // try --> getter getter_tail #METHOD_DEFINITION
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            getter(p)?;
            getter_tail(p)?;
            p.complete(_checkpoint.branch(&_marker), METHOD_DEFINITION);
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if (p.at_keyword("set") && p.at(IDENTIFIER)) && {
        // try --> setter setter_tail #METHOD_DEFINITION
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            setter(p)?;
            setter_tail(p)?;
            p.complete(_checkpoint.branch(&_marker), METHOD_DEFINITION);
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at_ts(&AT_GENERATOR_METHOD) {
        generator_method(p)?;
        p.complete(_checkpoint.branch(&_marker), METHOD_DEFINITION);
    } else {
        // otherwise, emit an error
        p.expected_ts_in("method_definition", &AT_METHOD_DEFINITION)?;
    }
    Some(Continue)
}

pub fn method_tail(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_PAREN)?;
        if p.at_ts(&tokenset![DOTDOTDOT, IDENTIFIER, L_CURLY, L_SQUARE]) {
            formal_parameter_list(p)?;
        }
        p.expect(R_PAREN)?;
        function_body(p)?;
        Some(Continue)
    });
    p.complete(_marker, FUNCTION_EXPRESSION);
    _ok
}

pub fn generator_method(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if p.at(ASTERISK) || (p.at_keyword("async") && p.at(IDENTIFIER)) {
            if p.at(ASTERISK) {
                p.bump();
            } else if p.at_keyword("async") && p.at(IDENTIFIER) {
                async_kw(p)?;
            }
        }
        identifier_name(p)?;
        p.expect(L_PAREN)?;
        if p.at_ts(&tokenset![DOTDOTDOT, IDENTIFIER, L_CURLY, L_SQUARE]) {
            formal_parameter_list(p)?;
        }
        p.expect(R_PAREN)?;
        function_body(p)?;
        Some(Continue)
    });
    p.complete(_marker, FUNCTION_EXPRESSION);
    _ok
}

pub fn formal_parameter_list(p: &mut Parser) -> Option<Continue> {
    if p.at(IDENTIFIER) {
        formal_parameter_arg(p)?;
        while p.at(COMMA) {
            let mut _checkpoint = p.checkpoint(true);
            catch!({
                p.bump();
                formal_parameter_arg(p)?;
                Some(Continue)
            });
            if !p.commit(_checkpoint)?.is_ok() {
                break;
            }
        }
        if p.at(COMMA) {
            p.bump();
            last_formal_parameter_arg(p)?;
        }
    } else if p.at(DOTDOTDOT) {
        last_formal_parameter_arg(p)?;
    } else if p.at(L_SQUARE) {
        array_expression(p)?;
    } else if p.at(L_CURLY) {
        object_expression(p)?;
    } else {
        p.expected_ts_in("formal_parameter_list", &tokenset![DOTDOTDOT, IDENTIFIER, L_CURLY, L_SQUARE])?;
    }
    Some(Continue)
}

pub fn formal_parameter_arg(p: &mut Parser) -> Option<Continue> {
    p.expect(IDENTIFIER)?;
    if p.at(EQ) {
        p.bump();
        expression(p)?;
    }
    Some(Continue)
}

pub fn last_formal_parameter_arg(p: &mut Parser) -> Option<Continue> {
    p.expect(DOTDOTDOT)?;
    p.expect(IDENTIFIER)?;
    Some(Continue)
}

pub fn function_body(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_CURLY)?;
        if p.at_ts(&_TS0) || (!p.at(L_CURLY) && !p.at(FUNCTION_KW) && p.at_ts(&_TS1)) {
            source_elements(p)?;
        }
        p.expect(R_CURLY)?;
        Some(Continue)
    });
    p.complete(_marker, BLOCK_STATEMENT);
    _ok
}

pub fn source_elements(p: &mut Parser) -> Option<Continue> {
    loop {
        source_element(p)?;
        if !(p.at_ts(&_TS0) || (!p.at(L_CURLY) && !p.at(FUNCTION_KW) && p.at_ts(&_TS1))) { break }
    }
    Some(Continue)
}

pub fn array_expression(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_SQUARE)?;
        while p.eat(COMMA) {}
        if p.at_ts(&AT_ELEMENT_LIST) {
            element_list(p)?;
        }
        while p.eat(COMMA) {}
        p.expect(R_SQUARE)?;
        Some(Continue)
    });
    p.complete(_marker, ARRAY_EXPRESSION);
    _ok
}

pub fn element_list(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&AT_EXPRESSION) {
        expression(p)?;
        while p.at(COMMA) {
            let mut _checkpoint = p.checkpoint(true);
            catch!({
                p.bump();
                while p.eat(COMMA) {}
                expression(p)?;
                Some(Continue)
            });
            if !p.commit(_checkpoint)?.is_ok() {
                break;
            }
        }
        if p.at(COMMA) {
            p.bump();
            while p.eat(COMMA) {}
            last_element(p)?;
        }
    } else if p.at(DOTDOTDOT) {
        last_element(p)?;
    } else {
        p.expected_ts_in("element_list", &AT_ELEMENT_LIST)?;
    }
    Some(Continue)
}

pub fn last_element(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(DOTDOTDOT)?;
        p.expect(IDENTIFIER)?;
        Some(Continue)
    });
    p.complete(_marker, SPREAD_ELEMENT);
    _ok
}

pub fn object_expression(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_CURLY)?;
        if p.at_ts(&AT_PROPERTY) {
            property(p)?;
            while p.at(COMMA) {
                p.bump();
                property(p)?;
            }
        }
        p.eat(COMMA);
        p.expect(R_CURLY)?;
        Some(Continue)
    });
    p.complete(_marker, OBJECT_EXPRESSION);
    _ok
}

pub fn property(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&AT_PROPERTY_NAME) && {
        // try --> property_name (: | =) expression #PROPERTY
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            let _marker = p.start();
            let _ok = catch!({
                property_name(p)?;
                p.expect_ts(&tokenset![COLON, EQ])?;
                expression(p)?;
                Some(Continue)
            });
            p.complete(_marker, PROPERTY);
            if _ok.is_none() {
                return None;
            }
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(L_SQUARE) {
        let _marker = p.start();
        let _ok = catch!({
            p.bump();
            expression(p)?;
            p.expect(R_SQUARE)?;
            p.expect(COLON)?;
            expression(p)?;
            Some(Continue)
        });
        p.complete(_marker, PROPERTY);
        if _ok.is_none() {
            return None;
        }
    } else if (p.at_keyword("get") && p.at(IDENTIFIER)) && {
        // try --> getter getter_tail #PROPERTY
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            let _marker = p.start();
            let _ok = catch!({
                getter(p)?;
                getter_tail(p)?;
                Some(Continue)
            });
            p.complete(_marker, PROPERTY);
            if _ok.is_none() {
                return None;
            }
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if (p.at_keyword("set") && p.at(IDENTIFIER)) && {
        // try --> setter setter_tail #PROPERTY
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            let _marker = p.start();
            let _ok = catch!({
                setter(p)?;
                setter_tail(p)?;
                Some(Continue)
            });
            p.complete(_marker, PROPERTY);
            if _ok.is_none() {
                return None;
            }
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at_ts(&AT_GENERATOR_METHOD) && {
        // try --> generator_method #PROPERTY
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            let _marker = p.start();
            let _ok = generator_method(p);
            p.complete(_marker, PROPERTY);
            if _ok.is_none() {
                return None;
            }
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(IDENTIFIER) {
        let _marker = p.start();
        p.bump();
        p.complete(_marker, PROPERTY);
    } else {
        // otherwise, emit an error
        p.expected_ts_in("property", &AT_PROPERTY)?;
    }
    Some(Continue)
}

pub fn property_name(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&AT_IDENTIFIER_NAME) {
        identifier_name(p)?;
    } else if p.at(STRING_LITERAL) {
        p.bump();
    } else if p.at(NUMBER_LITERAL) {
        p.bump();
    } else {
        p.expected_ts_in("property_name", &AT_PROPERTY_NAME)?;
    }
    Some(Continue)
}

pub fn getter_tail(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_PAREN)?;
        p.expect(R_PAREN)?;
        function_body(p)?;
        Some(Continue)
    });
    p.complete(_marker, FUNCTION_EXPRESSION);
    _ok
}

pub fn setter_tail(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_PAREN)?;
        p.expect(IDENTIFIER)?;
        p.expect(R_PAREN)?;
        function_body(p)?;
        Some(Continue)
    });
    p.complete(_marker, FUNCTION_EXPRESSION);
    _ok
}

pub fn arguments(p: &mut Parser) -> Option<Continue> {
    p.expect(L_PAREN)?;
    if p.at_ts(&AT_ELEMENT_LIST) {
        if p.at_ts(&AT_EXPRESSION) {
            expression(p)?;
            while p.at(COMMA) {
                let mut _checkpoint = p.checkpoint(true);
                catch!({
                    p.bump();
                    expression(p)?;
                    Some(Continue)
                });
                if !p.commit(_checkpoint)?.is_ok() {
                    break;
                }
            }
            if p.at(COMMA) {
                p.bump();
                last_argument(p)?;
            }
        } else if p.at(DOTDOTDOT) {
            last_argument(p)?;
        }
    }
    p.expect(R_PAREN)?;
    Some(Continue)
}

pub fn last_argument(p: &mut Parser) -> Option<Continue> {
    p.expect(DOTDOTDOT)?;
    p.expect(IDENTIFIER)?;
    Some(Continue)
}

pub fn expression_sequence(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        expression(p)?;
        while p.at(COMMA) {
            p.bump();
            expression(p)?;
        }
        Some(Continue)
    });
    p.complete(_marker, SEQUENCE_EXPRESSION);
    _ok
}

pub fn expression(p: &mut Parser) -> Option<Continue> {
    grammar_ext::expression(p)
}

pub fn class_expression(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(CLASS_KW)?;
        p.eat(IDENTIFIER);
        class_tail(p)?;
        Some(Continue)
    });
    p.complete(_marker, CLASS_EXPRESSION);
    _ok
}

pub fn function_expression(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(FUNCTION_KW)?;
        p.eat(IDENTIFIER);
        p.expect(L_PAREN)?;
        if p.at_ts(&tokenset![DOTDOTDOT, IDENTIFIER, L_CURLY, L_SQUARE]) {
            formal_parameter_list(p)?;
        }
        p.expect(R_PAREN)?;
        function_body(p)?;
        Some(Continue)
    });
    p.complete(_marker, FUNCTION_EXPRESSION);
    _ok
}

pub fn arrow_function_expression(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        arrow_function_parameters(p)?;
        p.expect(FAT_ARROW)?;
        arrow_function_body(p)?;
        Some(Continue)
    });
    p.complete(_marker, ARROW_FUNCTION_EXPRESSION);
    _ok
}

pub fn arrow_function_parameters(p: &mut Parser) -> Option<Continue> {
    if p.at(IDENTIFIER) {
        p.bump();
    } else if p.at(L_PAREN) {
        p.bump();
        if p.at_ts(&tokenset![DOTDOTDOT, IDENTIFIER, L_CURLY, L_SQUARE]) {
            formal_parameter_list(p)?;
        }
        p.expect(R_PAREN)?;
    } else {
        p.expected_ts_in("arrow_function_parameters", &tokenset![IDENTIFIER, L_PAREN])?;
    }
    Some(Continue)
}

pub fn arrow_function_body(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&AT_EXPRESSION) && {
        // try --> expression
        let mut _checkpoint = p.checkpoint(true);
        expression(p);
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(L_CURLY) {
        function_body(p)?;
    } else {
        // otherwise, emit an error
        p.expected_ts_in("arrow_function_body", &AT_EXPRESSION)?;
    }
    Some(Continue)
}

pub fn assignment_operator(p: &mut Parser) -> Option<Continue> {
    p.expect_ts(&AT_ASSIGNMENT_OPERATOR)
}

pub fn literal(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = p.expect_ts(&AT_LITERAL);
    p.complete(_marker, LITERAL);
    _ok
}

pub fn identifier_name(p: &mut Parser) -> Option<Continue> {
    if p.at(IDENTIFIER) {
        p.bump();
    } else if p.at_ts(&AT_RESERVED_WORD) {
        reserved_word(p)?;
    } else {
        p.expected_ts_in("identifier_name", &AT_IDENTIFIER_NAME)?;
    }
    Some(Continue)
}

pub fn reserved_word(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&AT_KEYWORD) {
        keyword(p)?;
    } else if p.at(NULL_KW) {
        p.bump();
    } else if p.at(TRUE_KW) {
        p.bump();
    } else if p.at(FALSE_KW) {
        p.bump();
    } else {
        p.expected_ts_in("reserved_word", &AT_RESERVED_WORD)?;
    }
    Some(Continue)
}

pub fn keyword(p: &mut Parser) -> Option<Continue> {
    p.expect_ts(&AT_KEYWORD)
}

pub fn getter(p: &mut Parser) -> Option<Continue> {
    get_kw(p)?;
    property_name(p)?;
    Some(Continue)
}

pub fn setter(p: &mut Parser) -> Option<Continue> {
    set_kw(p)?;
    property_name(p)?;
    Some(Continue)
}

pub fn as_kw(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if !(p.at_keyword("as")) {
            p.error("expected input to be at keyword 'as'")?;
        }
        p.expect(IDENTIFIER)?;
        Some(Continue)
    });
    p.complete(_marker, AS_KW);
    _ok
}

pub fn from_kw(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if !(p.at_keyword("from")) {
            p.error("expected input to be at keyword 'from'")?;
        }
        p.expect(IDENTIFIER)?;
        Some(Continue)
    });
    p.complete(_marker, FROM_KW);
    _ok
}

pub fn get_kw(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if !(p.at_keyword("get")) {
            p.error("expected input to be at keyword 'get'")?;
        }
        p.expect(IDENTIFIER)?;
        Some(Continue)
    });
    p.complete(_marker, GET_KW);
    _ok
}

pub fn set_kw(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if !(p.at_keyword("set")) {
            p.error("expected input to be at keyword 'set'")?;
        }
        p.expect(IDENTIFIER)?;
        Some(Continue)
    });
    p.complete(_marker, SET_KW);
    _ok
}

pub fn of_kw(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if !(p.at_keyword("of")) {
            p.error("expected input to be at keyword 'of'")?;
        }
        p.expect(IDENTIFIER)?;
        Some(Continue)
    });
    p.complete(_marker, OF_KW);
    _ok
}

pub fn async_kw(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if !(p.at_keyword("async")) {
            p.error("expected input to be at keyword 'async'")?;
        }
        p.expect(IDENTIFIER)?;
        Some(Continue)
    });
    p.complete(_marker, ASYNC_KW);
    _ok
}

pub fn eos(p: &mut Parser) -> Option<Continue> {
    if p.at(SEMICOLON) {
        p.bump();
    } else if p.at(EOF) {
        p.bump();
    } else if p.at_line_terminator() {
    } else if p.at(R_CURLY) {
    } else {
        p.expected_ts_in("eos", &tokenset![EOF, SEMICOLON])?;
    }
    Some(Continue)
}

const AT_ASSIGNMENT_OPERATOR: TokenSet = tokenset![AMPERSAND_EQ, ASTERISK_EQ, CARET_EQ, EQ, MINUS_EQ, PERCENT_EQ, PIPE_EQ, PLUS_EQ, SHL_EQ, SHR_EQ, SHU_EQ, SLASH_EQ];
const AT_CLASS_ELEMENT: TokenSet = tokenset![ASTERISK, BREAK_KW, CASE_KW, CATCH_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DEFAULT_KW, DELETE_KW, DO_KW, ELSE_KW, ENUM_KW, EXPORT_KW, EXTENDS_KW, FALSE_KW, FINALLY_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, IMPLEMENTS_KW, IMPORT_KW, INSTANCEOF_KW, INTERFACE_KW, IN_KW, LET_KW, NEW_KW, NULL_KW, NUMBER_LITERAL, PACKAGE_KW, PRIVATE_KW, PROTECTED_KW, PUBLIC_KW, RETURN_KW, SEMICOLON, STATIC_KW, STRING_LITERAL, SUPER_KW, SWITCH_KW, THIS_KW, THROW_KW, TRUE_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
const AT_ELEMENT_LIST: TokenSet = tokenset![AWAIT_KW, BANG, CLASS_KW, DECREMENT, DELETE_KW, DOTDOTDOT, FALSE_KW, FUNCTION_KW, IDENTIFIER, INCREMENT, L_CURLY, L_PAREN, L_SQUARE, MINUS, NEW_KW, NULL_KW, NUMBER_LITERAL, PLUS, REGEXP_LITERAL, STRING_LITERAL, SUPER_KW, TEMPLATE_LITERAL, THIS_KW, TILDE, TRUE_KW, TYPEOF_KW, VOID_KW, YIELD_KW];
const AT_EXPRESSION: TokenSet = tokenset![AWAIT_KW, BANG, CLASS_KW, DECREMENT, DELETE_KW, FALSE_KW, FUNCTION_KW, IDENTIFIER, INCREMENT, L_CURLY, L_PAREN, L_SQUARE, MINUS, NEW_KW, NULL_KW, NUMBER_LITERAL, PLUS, REGEXP_LITERAL, STRING_LITERAL, SUPER_KW, TEMPLATE_LITERAL, THIS_KW, TILDE, TRUE_KW, TYPEOF_KW, VOID_KW, YIELD_KW];
const AT_GENERATOR_METHOD: TokenSet = tokenset![ASTERISK, BREAK_KW, CASE_KW, CATCH_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DEFAULT_KW, DELETE_KW, DO_KW, ELSE_KW, ENUM_KW, EXPORT_KW, EXTENDS_KW, FALSE_KW, FINALLY_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, IMPLEMENTS_KW, IMPORT_KW, INSTANCEOF_KW, INTERFACE_KW, IN_KW, LET_KW, NEW_KW, NULL_KW, PACKAGE_KW, PRIVATE_KW, PROTECTED_KW, PUBLIC_KW, RETURN_KW, STATIC_KW, SUPER_KW, SWITCH_KW, THIS_KW, THROW_KW, TRUE_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
const AT_IDENTIFIER_NAME: TokenSet = tokenset![BREAK_KW, CASE_KW, CATCH_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DEFAULT_KW, DELETE_KW, DO_KW, ELSE_KW, ENUM_KW, EXPORT_KW, EXTENDS_KW, FALSE_KW, FINALLY_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, IMPLEMENTS_KW, IMPORT_KW, INSTANCEOF_KW, INTERFACE_KW, IN_KW, LET_KW, NEW_KW, NULL_KW, PACKAGE_KW, PRIVATE_KW, PROTECTED_KW, PUBLIC_KW, RETURN_KW, STATIC_KW, SUPER_KW, SWITCH_KW, THIS_KW, THROW_KW, TRUE_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
const AT_KEYWORD: TokenSet = tokenset![BREAK_KW, CASE_KW, CATCH_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DEFAULT_KW, DELETE_KW, DO_KW, ELSE_KW, ENUM_KW, EXPORT_KW, EXTENDS_KW, FINALLY_KW, FOR_KW, FUNCTION_KW, IF_KW, IMPLEMENTS_KW, IMPORT_KW, INSTANCEOF_KW, INTERFACE_KW, IN_KW, LET_KW, NEW_KW, PACKAGE_KW, PRIVATE_KW, PROTECTED_KW, PUBLIC_KW, RETURN_KW, STATIC_KW, SUPER_KW, SWITCH_KW, THIS_KW, THROW_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
const AT_LITERAL: TokenSet = tokenset![FALSE_KW, NULL_KW, NUMBER_LITERAL, REGEXP_LITERAL, STRING_LITERAL, TEMPLATE_LITERAL, TRUE_KW];
const AT_METHOD_DEFINITION: TokenSet = tokenset![ASTERISK, BREAK_KW, CASE_KW, CATCH_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DEFAULT_KW, DELETE_KW, DO_KW, ELSE_KW, ENUM_KW, EXPORT_KW, EXTENDS_KW, FALSE_KW, FINALLY_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, IMPLEMENTS_KW, IMPORT_KW, INSTANCEOF_KW, INTERFACE_KW, IN_KW, LET_KW, NEW_KW, NULL_KW, NUMBER_LITERAL, PACKAGE_KW, PRIVATE_KW, PROTECTED_KW, PUBLIC_KW, RETURN_KW, STATIC_KW, STRING_LITERAL, SUPER_KW, SWITCH_KW, THIS_KW, THROW_KW, TRUE_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
const AT_PROPERTY: TokenSet = tokenset![ASTERISK, BREAK_KW, CASE_KW, CATCH_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DEFAULT_KW, DELETE_KW, DO_KW, ELSE_KW, ENUM_KW, EXPORT_KW, EXTENDS_KW, FALSE_KW, FINALLY_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, IMPLEMENTS_KW, IMPORT_KW, INSTANCEOF_KW, INTERFACE_KW, IN_KW, LET_KW, L_SQUARE, NEW_KW, NULL_KW, NUMBER_LITERAL, PACKAGE_KW, PRIVATE_KW, PROTECTED_KW, PUBLIC_KW, RETURN_KW, STATIC_KW, STRING_LITERAL, SUPER_KW, SWITCH_KW, THIS_KW, THROW_KW, TRUE_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
const AT_PROPERTY_NAME: TokenSet = tokenset![BREAK_KW, CASE_KW, CATCH_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DEFAULT_KW, DELETE_KW, DO_KW, ELSE_KW, ENUM_KW, EXPORT_KW, EXTENDS_KW, FALSE_KW, FINALLY_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, IMPLEMENTS_KW, IMPORT_KW, INSTANCEOF_KW, INTERFACE_KW, IN_KW, LET_KW, NEW_KW, NULL_KW, NUMBER_LITERAL, PACKAGE_KW, PRIVATE_KW, PROTECTED_KW, PUBLIC_KW, RETURN_KW, STATIC_KW, STRING_LITERAL, SUPER_KW, SWITCH_KW, THIS_KW, THROW_KW, TRUE_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
const AT_RESERVED_WORD: TokenSet = tokenset![BREAK_KW, CASE_KW, CATCH_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DEFAULT_KW, DELETE_KW, DO_KW, ELSE_KW, ENUM_KW, EXPORT_KW, EXTENDS_KW, FALSE_KW, FINALLY_KW, FOR_KW, FUNCTION_KW, IF_KW, IMPLEMENTS_KW, IMPORT_KW, INSTANCEOF_KW, INTERFACE_KW, IN_KW, LET_KW, NEW_KW, NULL_KW, PACKAGE_KW, PRIVATE_KW, PROTECTED_KW, PUBLIC_KW, RETURN_KW, STATIC_KW, SUPER_KW, SWITCH_KW, THIS_KW, THROW_KW, TRUE_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
const AT_SOURCE_ELEMENT: TokenSet = tokenset![AWAIT_KW, BANG, BREAK_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DECREMENT, DELETE_KW, DO_KW, EXPORT_KW, FALSE_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, IMPORT_KW, INCREMENT, LET_KW, L_CURLY, L_PAREN, L_SQUARE, MINUS, NEW_KW, NULL_KW, NUMBER_LITERAL, PLUS, REGEXP_LITERAL, RETURN_KW, SEMICOLON, STRING_LITERAL, SUPER_KW, SWITCH_KW, TEMPLATE_LITERAL, THIS_KW, THROW_KW, TILDE, TRUE_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
const AT_STATEMENT: TokenSet = tokenset![AWAIT_KW, BANG, BREAK_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DECREMENT, DELETE_KW, DO_KW, FALSE_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, INCREMENT, LET_KW, L_CURLY, L_PAREN, L_SQUARE, MINUS, NEW_KW, NULL_KW, NUMBER_LITERAL, PLUS, REGEXP_LITERAL, RETURN_KW, SEMICOLON, STRING_LITERAL, SUPER_KW, SWITCH_KW, TEMPLATE_LITERAL, THIS_KW, THROW_KW, TILDE, TRUE_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
const _TS0: TokenSet = tokenset![BREAK_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DO_KW, EXPORT_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, IMPORT_KW, LET_KW, L_CURLY, RETURN_KW, SEMICOLON, SWITCH_KW, THROW_KW, TRY_KW, VAR_KW, WHILE_KW, WITH_KW];
const _TS1: TokenSet = tokenset![AWAIT_KW, BANG, DECREMENT, DELETE_KW, FALSE_KW, INCREMENT, L_PAREN, L_SQUARE, MINUS, NEW_KW, NULL_KW, NUMBER_LITERAL, PLUS, REGEXP_LITERAL, STRING_LITERAL, SUPER_KW, TEMPLATE_LITERAL, THIS_KW, TILDE, TRUE_KW, TYPEOF_KW, VOID_KW, YIELD_KW];
const _TS2: TokenSet = tokenset![BREAK_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DO_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, LET_KW, L_CURLY, RETURN_KW, SEMICOLON, SWITCH_KW, THROW_KW, TRY_KW, VAR_KW, WHILE_KW, WITH_KW];
const _TS3: TokenSet = tokenset![ASTERISK, CONST_KW, DEFAULT_KW, LET_KW, L_CURLY, VAR_KW];
const _TS4: TokenSet = tokenset![AWAIT_KW, BANG, CLASS_KW, DECREMENT, DELETE_KW, FALSE_KW, FUNCTION_KW, IDENTIFIER, INCREMENT, L_CURLY, L_PAREN, L_SQUARE, MINUS, NEW_KW, NULL_KW, NUMBER_LITERAL, PLUS, REGEXP_LITERAL, SEMICOLON, STRING_LITERAL, SUPER_KW, TEMPLATE_LITERAL, THIS_KW, TILDE, TRUE_KW, TYPEOF_KW, VOID_KW, YIELD_KW];
const _TS5: TokenSet = tokenset![AWAIT_KW, BANG, CLASS_KW, CONST_KW, DECREMENT, DELETE_KW, FALSE_KW, FUNCTION_KW, IDENTIFIER, INCREMENT, LET_KW, L_CURLY, L_PAREN, L_SQUARE, MINUS, NEW_KW, NULL_KW, NUMBER_LITERAL, PLUS, REGEXP_LITERAL, SEMICOLON, STRING_LITERAL, SUPER_KW, TEMPLATE_LITERAL, THIS_KW, TILDE, TRUE_KW, TYPEOF_KW, VAR_KW, VOID_KW, YIELD_KW];

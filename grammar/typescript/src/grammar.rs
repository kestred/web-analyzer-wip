// This file is automatically generated by running `cargo run -p antlr_codegen`.
//
// =====================
// Do not edit manually.
// =====================
//
#![allow(dead_code)]
#![allow(unused_imports)]

//! This module contains an auto-generated TYPESCRIPT parser.
use crate::syntax_kind::*;
use code_grammar::{catch, tokenset, Parser, TokenSet};
use code_grammar::parser::Continue;

pub use crate::grammar_ext::{expression, type_expr};

pub fn program(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.eat(SHEBANG);
        if p.at_ts(&_TS0) || (!p.at(L_CURLY) && !p.at(FUNCTION_KW) && p.at_ts(&_TS1)) {
            source_elements(p)?;
        }
        p.expect(EOF)?;
        Some(Continue)
    });
    p.complete(_marker, PROGRAM);
    _ok
}

pub fn export_declaration(p: &mut Parser) -> Option<Continue> {
    let mut _checkpoint = p.checkpoint(false);
    let _marker = p.start();
    p.expect(EXPORT_KW)?;
    if p.at(L_CURLY) {
        p.bump();
        export_specifier_list(p)?;
        p.expect(R_CURLY)?;
        if p.at_keyword("from") && p.at(IDENTIFIER) {
            from_kw(p)?;
            if !(p.at(STRING_LITERAL)) {
                p.error("expected to be at STRING_LITERAL")?;
            }
            literal(p)?;
        }
        eos(p)?;
        p.complete(_checkpoint.branch(&_marker), EXPORT_NAMED_DECLARATION);
    } else if p.at_ts(&tokenset![CONST_KW, LET_KW, VAR_KW]) {
        variable_declaration(p)?;
        eos(p)?;
        p.complete(_checkpoint.branch(&_marker), EXPORT_NAMED_DECLARATION);
    } else if p.at(INTERFACE_KW) {
        interface_declaration(p)?;
        p.complete(_checkpoint.branch(&_marker), EXPORT_NAMED_DECLARATION);
    } else if p.at_keyword("type") && p.at(IDENTIFIER) {
        alias_declaration(p)?;
        eos(p)?;
        p.complete(_checkpoint.branch(&_marker), EXPORT_NAMED_DECLARATION);
    } else if p.at(ENUM_KW) {
        enum_declaration(p)?;
        p.complete(_checkpoint.branch(&_marker), EXPORT_NAMED_DECLARATION);
    } else if p.at(DEFAULT_KW) && {
        // try --> DEFAULT_KW class_declaration #EXPORT_DEFAULT_DECLARATION
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            p.bump();
            class_declaration(p)?;
            p.complete(_checkpoint.branch(&_marker), EXPORT_DEFAULT_DECLARATION);
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(DEFAULT_KW) && {
        // try --> DEFAULT_KW function_declaration #EXPORT_DEFAULT_DECLARATION
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            p.bump();
            function_declaration(p)?;
            p.complete(_checkpoint.branch(&_marker), EXPORT_DEFAULT_DECLARATION);
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(DEFAULT_KW) {
        p.bump();
        expression(p)?;
        eos(p)?;
        p.complete(_checkpoint.branch(&_marker), EXPORT_DEFAULT_DECLARATION);
    } else if p.at(ASTERISK) {
        p.bump();
        from_kw(p)?;
        if !(p.at(STRING_LITERAL)) {
            p.error("expected to be at STRING_LITERAL")?;
        }
        literal(p)?;
        eos(p)?;
        p.complete(_checkpoint.branch(&_marker), EXPORT_ALL_DECLARATION);
    } else {
        // otherwise, emit an error
        p.expected_ts_in("export_declaration", &_TS2)?;
    }
    Some(Continue)
}

pub fn statement(p: &mut Parser) -> Option<Continue> {
    if p.at(L_CURLY) && {
        // try --> block
        let mut _checkpoint = p.checkpoint(true);
        block(p);
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(SEMICOLON) {
        empty_statement(p)?;
    } else if p.at(IF_KW) {
        if_statement(p)?;
    } else if p.at(FOR_KW) {
        for_statement(p)?;
    } else if p.at(WHILE_KW) {
        while_statement(p)?;
    } else if p.at(DO_KW) {
        do_while_statement(p)?;
    } else if p.at(CONTINUE_KW) {
        continue_statement(p)?;
    } else if p.at(BREAK_KW) {
        break_statement(p)?;
    } else if p.at(RETURN_KW) {
        return_statement(p)?;
    } else if p.at(WITH_KW) {
        with_statement(p)?;
    } else if p.at(SWITCH_KW) {
        switch_statement(p)?;
    } else if p.at(THROW_KW) {
        throw_statement(p)?;
    } else if p.at(TRY_KW) {
        try_statement(p)?;
    } else if p.at(DEBUGGER_KW) {
        debugger_statement(p)?;
    } else if p.at(CLASS_KW) && {
        // try --> class_declaration
        let mut _checkpoint = p.checkpoint(true);
        class_declaration(p);
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at_ts(&tokenset![CONST_KW, LET_KW, VAR_KW]) {
        variable_declaration(p)?;
        eos(p)?;
    } else if (p.at(FUNCTION_KW) || (p.at_keyword("async") && p.at(IDENTIFIER))) && {
        // try --> function_declaration
        let mut _checkpoint = p.checkpoint(true);
        function_declaration(p);
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(INTERFACE_KW) {
        interface_declaration(p)?;
    } else if (p.at_keyword("type") && p.at(IDENTIFIER)) && {
        // try --> alias_declaration
        let mut _checkpoint = p.checkpoint(true);
        alias_declaration(p);
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(ENUM_KW) {
        enum_declaration(p)?;
    } else if ((p.at_keyword("async") && !p.at(L_CURLY) && !p.at(FUNCTION_KW) && p.at(IDENTIFIER)) || (!p.at(L_CURLY) && !p.at(FUNCTION_KW) && p.at_ts(&AT_EXPRESSION_LIST_OR_EXPRESSION))) && {
        // try --> expression_statement
        let mut _checkpoint = p.checkpoint(true);
        expression_statement(p);
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(IDENTIFIER) {
        labeled_statement(p)?;
    } else {
        // otherwise, emit an error
        p.expected_ts_in("statement", &AT_STATEMENT)?;
    }
    Some(Continue)
}

pub fn interface_declaration(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(INTERFACE_KW)?;
        identifier(p)?;
        p.expect(L_CURLY)?;
        while p.at_ts(&AT_INTERFACE_PROPERTY_OR_ASSIGNMENT_PROPERTY) {
            let mut _checkpoint = p.checkpoint(true);
            catch!({
                interface_property(p)?;
                eos(p)?;
                Some(Continue)
            });
            if !p.commit(_checkpoint)?.is_ok() {
                break;
            }
        }
        p.expect(R_CURLY)?;
        Some(Continue)
    });
    p.complete(_marker, INTERFACE_DECLARATION);
    _ok
}

pub fn interface_property(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&AT_IDENTIFIER_OR_KEYWORD) {
        let _marker = p.start();
        let _ok = catch!({
            identifier_or_keyword(p)?;
            p.eat(QUESTION);
            p.expect(COLON)?;
            type_expr(p)?;
            Some(Continue)
        });
        p.complete(_marker, INTERFACE_PROPERTY);
        if _ok.is_none() {
            return None;
        }
    } else if p.at(L_SQUARE) {
        let _marker = p.start();
        let _ok = catch!({
            p.bump();
            identifier(p)?;
            p.expect(COLON)?;
            type_expr(p)?;
            p.expect(R_SQUARE)?;
            p.expect(COLON)?;
            type_expr(p)?;
            Some(Continue)
        });
        p.complete(_marker, INTERFACE_PROPERTY);
        if _ok.is_none() {
            return None;
        }
    } else {
        p.expected_ts_in("interface_property", &AT_INTERFACE_PROPERTY_OR_ASSIGNMENT_PROPERTY)?;
    }
    Some(Continue)
}

pub fn alias_declaration(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        type_kw(p)?;
        identifier(p)?;
        p.expect(EQ)?;
        type_expr(p)?;
        eos(p)?;
        Some(Continue)
    });
    p.complete(_marker, ALIAS_DECLARATION);
    _ok
}

pub fn enum_declaration(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(ENUM_KW)?;
        identifier(p)?;
        p.expect(L_CURLY)?;
        while p.at(IDENTIFIER) {
            let mut _checkpoint = p.checkpoint(true);
            catch!({
                enum_variant(p)?;
                p.expect(COMMA)?;
                Some(Continue)
            });
            if !p.commit(_checkpoint)?.is_ok() {
                break;
            }
        }
        p.expect(R_CURLY)?;
        Some(Continue)
    });
    p.complete(_marker, ENUM_DECLARATION);
    _ok
}

pub fn enum_variant(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        identifier(p)?;
        if p.at(EQ) {
            p.bump();
            expression(p)?;
        }
        Some(Continue)
    });
    p.complete(_marker, ENUM_VARIANT);
    _ok
}

pub(crate) fn _type_expr_interface(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_CURLY)?;
        while p.at_ts(&AT_INTERFACE_PROPERTY_OR_ASSIGNMENT_PROPERTY) {
            let mut _checkpoint = p.checkpoint(true);
            catch!({
                interface_property(p)?;
                eos(p)?;
                Some(Continue)
            });
            if !p.commit(_checkpoint)?.is_ok() {
                break;
            }
        }
        p.expect(R_CURLY)?;
        Some(Continue)
    });
    p.complete(_marker, INTERFACE_TYPE_EXPR);
    _ok
}

pub(crate) fn _type_expr_function(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_PAREN)?;
        p.expect(R_PAREN)?;
        p.expect(FAT_ARROW)?;
        type_expr(p)?;
        Some(Continue)
    });
    p.complete(_marker, FUNCTION_TYPE_EXPR);
    _ok
}

pub(crate) fn _type_expr_tuple(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_SQUARE)?;
        if p.at_ts(&AT_TYPE_EXPR) {
            type_expr(p)?;
            while p.at(COMMA) {
                p.bump();
                type_expr(p)?;
            }
        }
        p.expect(R_SQUARE)?;
        Some(Continue)
    });
    p.complete(_marker, TUPLE_TYPE_EXPR);
    _ok
}

pub(crate) fn _type_expr_typeof(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(TYPEOF_KW)?;
        identifier(p)?;
        Some(Continue)
    });
    p.complete(_marker, TYPEOF_TYPE_EXPR);
    _ok
}

pub fn type_arguments(p: &mut Parser) -> Option<Continue> {
    p.expect(L_ANGLE)?;
    type_expr(p)?;
    while p.at(COMMA) {
        p.bump();
        type_expr(p)?;
    }
    p.expect(R_ANGLE)?;
    Some(Continue)
}

pub fn object_pattern(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_CURLY)?;
        if p.at_ts(&AT_INTERFACE_PROPERTY_OR_ASSIGNMENT_PROPERTY) {
            assignment_property(p)?;
            while p.at(COMMA) {
                p.bump();
                assignment_property(p)?;
            }
        }
        p.expect(R_CURLY)?;
        if p.at(COLON) {
            p.bump();
            type_expr(p)?;
        }
        Some(Continue)
    });
    p.complete(_marker, OBJECT_PATTERN);
    _ok
}

pub fn array_pattern(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_SQUARE)?;
        while p.eat(COMMA) {}
        if p.at_ts(&tokenset![DOTDOTDOT, IDENTIFIER, L_CURLY, L_SQUARE]) {
            pattern(p)?;
            while p.at(COMMA) {
                p.bump();
                while p.eat(COMMA) {}
                pattern(p)?;
            }
        }
        while p.eat(COMMA) {}
        p.expect(R_SQUARE)?;
        if p.at(COLON) {
            p.bump();
            type_expr(p)?;
        }
        Some(Continue)
    });
    p.complete(_marker, ARRAY_PATTERN);
    _ok
}

pub fn identifier_pattern(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(IDENTIFIER)?;
        if p.at_ts(&tokenset![COLON, QUESTION]) {
            let mut _checkpoint = p.checkpoint(true);
            catch!({
                p.eat(QUESTION);
                p.expect(COLON)?;
                type_expr(p)?;
                Some(Continue)
            });
            p.commit(_checkpoint)?.ok();
        }
        Some(Continue)
    });
    p.complete(_marker, IDENTIFIER);
    _ok
}

pub fn identifier_or_primitive(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = p.expect_ts(&tokenset![BOOLEAN_KW, IDENTIFIER]);
    p.complete(_marker, IDENTIFIER);
    _ok
}

pub fn function_parameters(p: &mut Parser) -> Option<Continue> {
    p.expect(L_PAREN)?;
    if p.at_ts(&tokenset![DOTDOTDOT, IDENTIFIER, L_CURLY, L_SQUARE]) {
        formal_parameter_list(p)?;
    }
    p.expect(R_PAREN)?;
    if p.at(COLON) {
        p.bump();
        type_expr(p)?;
    }
    Some(Continue)
}

pub fn type_kw(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if !(p.at_keyword("type")) {
            p.error("expected to be at keyword 'type'")?;
        }
        p.expect(IDENTIFIER)?;
        Some(Continue)
    });
    p.complete(_marker, TYPE_KW);
    _ok
}

pub fn source_element(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&_TS3) || (!p.at(L_CURLY) && !p.at(FUNCTION_KW) && p.at_ts(&_TS1)) {
        statement(p)?;
    } else if p.at_ts(&tokenset![EXPORT_KW, IMPORT_KW]) {
        module_declaration(p)?;
    } else {
        p.expected_ts_in("source_element", &AT_SOURCE_ELEMENT)?;
    }
    Some(Continue)
}

pub fn module_declaration(p: &mut Parser) -> Option<Continue> {
    if p.at(IMPORT_KW) {
        import_declaration(p)?;
    } else if p.at(EXPORT_KW) {
        export_declaration(p)?;
    } else {
        p.expected_ts_in("module_declaration", &tokenset![EXPORT_KW, IMPORT_KW])?;
    }
    Some(Continue)
}

pub fn export_specifier_list(p: &mut Parser) -> Option<Continue> {
    export_specifier_atom(p)?;
    while p.at(COMMA) {
        p.bump();
        export_specifier_atom(p)?;
    }
    Some(Continue)
}

pub fn export_specifier_atom(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        identifier(p)?;
        if p.at_keyword("as") && p.at(IDENTIFIER) {
            as_kw(p)?;
            identifier(p)?;
        }
        Some(Continue)
    });
    p.complete(_marker, EXPORT_SPECIFIER);
    _ok
}

pub fn import_declaration(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(IMPORT_KW)?;
        import_declaration_list(p)?;
        from_kw(p)?;
        if !(p.at(STRING_LITERAL)) {
            p.error("expected to be at STRING_LITERAL")?;
        }
        literal(p)?;
        eos(p)?;
        Some(Continue)
    });
    p.complete(_marker, IMPORT_DECLARATION);
    _ok
}

pub fn import_declaration_list(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&tokenset![ASTERISK, IDENTIFIER]) {
        import_specifier_special(p)?;
        if p.at(COMMA) {
            p.bump();
            p.expect(L_CURLY)?;
            import_specifier_list(p)?;
            p.expect(R_CURLY)?;
        }
    } else if p.at(L_CURLY) {
        p.bump();
        import_specifier_list(p)?;
        p.expect(R_CURLY)?;
    } else {
        p.expected_ts_in("import_declaration_list", &tokenset![ASTERISK, IDENTIFIER, L_CURLY])?;
    }
    Some(Continue)
}

pub fn import_specifier_list(p: &mut Parser) -> Option<Continue> {
    import_specifier_atom(p)?;
    while p.at(COMMA) {
        p.bump();
        import_specifier_atom(p)?;
    }
    Some(Continue)
}

pub fn import_specifier_atom(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        identifier(p)?;
        if p.at_keyword("as") && p.at(IDENTIFIER) {
            as_kw(p)?;
            identifier(p)?;
        }
        Some(Continue)
    });
    p.complete(_marker, IMPORT_SPECIFIER);
    _ok
}

pub fn import_specifier_special(p: &mut Parser) -> Option<Continue> {
    if p.at(IDENTIFIER) {
        let _marker = p.start();
        let _ok = identifier(p);
        p.complete(_marker, IMPORT_DEFAULT_SPECIFIER);
        if _ok.is_none() {
            return None;
        }
    } else if p.at(ASTERISK) {
        let _marker = p.start();
        let _ok = catch!({
            p.bump();
            as_kw(p)?;
            identifier(p)?;
            Some(Continue)
        });
        p.complete(_marker, IMPORT_NAMESPACE_SPECIFIER);
        if _ok.is_none() {
            return None;
        }
    } else {
        p.expected_ts_in("import_specifier_special", &tokenset![ASTERISK, IDENTIFIER])?;
    }
    Some(Continue)
}

pub fn block(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_CURLY)?;
        if p.at_ts(&_TS3) || (!p.at(L_CURLY) && !p.at(FUNCTION_KW) && p.at_ts(&_TS1)) {
            statement_list(p)?;
        }
        p.expect(R_CURLY)?;
        Some(Continue)
    });
    p.complete(_marker, BLOCK_STATEMENT);
    _ok
}

pub fn statement_list(p: &mut Parser) -> Option<Continue> {
    statement(p)?;
    while p.at_ts(&_TS3) || (!p.at(L_CURLY) && !p.at(FUNCTION_KW) && p.at_ts(&_TS1)) {
        let mut _checkpoint = p.checkpoint(true);
        statement(p);
        if !p.commit(_checkpoint)?.is_ok() {
            break;
        }
    }
    Some(Continue)
}

pub fn variable_declaration(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        variable_declaration_kind(p)?;
        variable_declarator_list(p)?;
        Some(Continue)
    });
    p.complete(_marker, VARIABLE_DECLARATION);
    _ok
}

pub fn variable_declaration_kind(p: &mut Parser) -> Option<Continue> {
    p.expect_ts(&tokenset![CONST_KW, LET_KW, VAR_KW])
}

pub fn variable_declarator_list(p: &mut Parser) -> Option<Continue> {
    variable_declarator(p)?;
    while p.at(COMMA) {
        p.bump();
        variable_declarator(p)?;
    }
    Some(Continue)
}

pub fn variable_declarator(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        pattern(p)?;
        if p.at(EQ) {
            p.bump();
            expression(p)?;
        }
        Some(Continue)
    });
    p.complete(_marker, VARIABLE_DECLARATOR);
    _ok
}

pub fn empty_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = p.expect(SEMICOLON);
    p.complete(_marker, EMPTY_STATEMENT);
    _ok
}

pub fn expression_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if !(!p.at(L_CURLY) && !p.at(FUNCTION_KW)) {
            p.error("expected to be not at L_CURLY and not at FUNCTION_KW")?;
        }
        expression_list(p)?;
        eos(p)?;
        Some(Continue)
    });
    p.complete(_marker, EXPRESSION_STATEMENT);
    _ok
}

pub fn if_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(IF_KW)?;
        p.expect(L_PAREN)?;
        expression_list(p)?;
        p.expect(R_PAREN)?;
        statement(p)?;
        if p.at(ELSE_KW) {
            p.bump();
            statement(p)?;
        }
        Some(Continue)
    });
    p.complete(_marker, IF_STATEMENT);
    _ok
}

pub fn for_statement(p: &mut Parser) -> Option<Continue> {
    let mut _checkpoint = p.checkpoint(false);
    let _marker = p.start();
    p.expect(FOR_KW)?;
    p.expect(L_PAREN)?;
    if p.at_ts(&_TS4) && {
        // try --> (expression_list)? ; (expression_list)? ; (expression_list)? ) statement_list #FOR_STATEMENT
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            if p.at_ts(&AT_EXPRESSION_LIST_OR_EXPRESSION) {
                expression_list(p)?;
            }
            p.expect(SEMICOLON)?;
            if p.at_ts(&AT_EXPRESSION_LIST_OR_EXPRESSION) {
                expression_list(p)?;
            }
            p.expect(SEMICOLON)?;
            if p.at_ts(&AT_EXPRESSION_LIST_OR_EXPRESSION) {
                expression_list(p)?;
            }
            p.expect(R_PAREN)?;
            statement_list(p)?;
            p.complete(_checkpoint.branch(&_marker), FOR_STATEMENT);
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at_ts(&tokenset![CONST_KW, LET_KW, VAR_KW]) && {
        // try --> variable_declaration ; (expression_list)? ; (expression_list)? ) statement #FOR_STATEMENT
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            variable_declaration(p)?;
            p.expect(SEMICOLON)?;
            if p.at_ts(&AT_EXPRESSION_LIST_OR_EXPRESSION) {
                expression_list(p)?;
            }
            p.expect(SEMICOLON)?;
            if p.at_ts(&AT_EXPRESSION_LIST_OR_EXPRESSION) {
                expression_list(p)?;
            }
            p.expect(R_PAREN)?;
            statement(p)?;
            p.complete(_checkpoint.branch(&_marker), FOR_STATEMENT);
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at_ts(&AT_EXPRESSION_LIST_OR_EXPRESSION) && {
        // try --> expression IN_KW expression ) statement_list #FOR_IN_STATEMENT
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            expression(p)?;
            p.expect(IN_KW)?;
            expression(p)?;
            p.expect(R_PAREN)?;
            statement_list(p)?;
            p.complete(_checkpoint.branch(&_marker), FOR_IN_STATEMENT);
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at_ts(&tokenset![CONST_KW, LET_KW, VAR_KW]) && {
        // try --> variable_declaration IN_KW expression ) statement #FOR_IN_STATEMENT
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            variable_declaration(p)?;
            p.expect(IN_KW)?;
            expression(p)?;
            p.expect(R_PAREN)?;
            statement(p)?;
            p.complete(_checkpoint.branch(&_marker), FOR_IN_STATEMENT);
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at_ts(&AT_EXPRESSION_LIST_OR_EXPRESSION) {
        expression(p)?;
        of_kw(p)?;
        expression(p)?;
        p.expect(R_PAREN)?;
        statement_list(p)?;
        p.complete(_checkpoint.branch(&_marker), FOR_OF_STATEMENT);
    } else if p.at_ts(&tokenset![CONST_KW, LET_KW, VAR_KW]) {
        variable_declaration(p)?;
        of_kw(p)?;
        expression(p)?;
        p.expect(R_PAREN)?;
        statement(p)?;
        p.complete(_checkpoint.branch(&_marker), FOR_OF_STATEMENT);
    } else {
        // otherwise, emit an error
        p.expected_ts_in("for_statement", &_TS5)?;
    }
    Some(Continue)
}

pub fn while_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(WHILE_KW)?;
        p.expect(L_PAREN)?;
        expression_list(p)?;
        p.expect(R_PAREN)?;
        statement(p)?;
        Some(Continue)
    });
    p.complete(_marker, WHILE_STATEMENT);
    _ok
}

pub fn do_while_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(DO_KW)?;
        statement(p)?;
        p.expect(WHILE_KW)?;
        p.expect(L_PAREN)?;
        expression_list(p)?;
        p.expect(R_PAREN)?;
        eos(p)?;
        Some(Continue)
    });
    p.complete(_marker, DO_WHILE_STATEMENT);
    _ok
}

pub fn continue_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(CONTINUE_KW)?;
        if !p.at_line_terminator() && p.at(IDENTIFIER) {
            identifier(p)?;
        }
        eos(p)?;
        Some(Continue)
    });
    p.complete(_marker, CONTINUE_STATEMENT);
    _ok
}

pub fn break_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(BREAK_KW)?;
        if !p.at_line_terminator() && p.at(IDENTIFIER) {
            identifier(p)?;
        }
        eos(p)?;
        Some(Continue)
    });
    p.complete(_marker, BREAK_STATEMENT);
    _ok
}

pub fn return_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(RETURN_KW)?;
        if (!p.at_line_terminator() && p.at_ts(&AT_EXPRESSION_LIST_OR_EXPRESSION)) || (p.at_keyword("async") && !p.at_line_terminator() && p.at(IDENTIFIER)) {
            if !(!p.at_line_terminator()) {
                p.error("expected to be not at line terminator")?;
            }
            expression_list(p)?;
        }
        eos(p)?;
        Some(Continue)
    });
    p.complete(_marker, RETURN_STATEMENT);
    _ok
}

pub fn with_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(WITH_KW)?;
        p.expect(L_PAREN)?;
        expression_list(p)?;
        p.expect(R_PAREN)?;
        statement(p)?;
        Some(Continue)
    });
    p.complete(_marker, WITH_STATEMENT);
    _ok
}

pub fn switch_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(SWITCH_KW)?;
        p.expect(L_PAREN)?;
        expression_list(p)?;
        p.expect(R_PAREN)?;
        case_block(p)?;
        Some(Continue)
    });
    p.complete(_marker, SWITCH_STATEMENT);
    _ok
}

pub fn case_block(p: &mut Parser) -> Option<Continue> {
    p.expect(L_CURLY)?;
    if p.at(CASE_KW) {
        case_clauses(p)?;
    }
    if p.at(DEFAULT_KW) {
        default_clause(p)?;
        if p.at(CASE_KW) {
            case_clauses(p)?;
        }
    }
    p.expect(R_CURLY)?;
    Some(Continue)
}

pub fn case_clauses(p: &mut Parser) -> Option<Continue> {
    case_clause(p)?;
    while p.at(CASE_KW) {
        let mut _checkpoint = p.checkpoint(true);
        case_clause(p);
        if !p.commit(_checkpoint)?.is_ok() {
            break;
        }
    }
    Some(Continue)
}

pub fn case_clause(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(CASE_KW)?;
        expression_list(p)?;
        p.expect(COLON)?;
        if p.at_ts(&_TS3) || (!p.at(L_CURLY) && !p.at(FUNCTION_KW) && p.at_ts(&_TS1)) {
            statement_list(p)?;
        }
        Some(Continue)
    });
    p.complete(_marker, SWITCH_CASE);
    _ok
}

pub fn default_clause(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(DEFAULT_KW)?;
        p.expect(COLON)?;
        if p.at_ts(&_TS3) || (!p.at(L_CURLY) && !p.at(FUNCTION_KW) && p.at_ts(&_TS1)) {
            statement_list(p)?;
        }
        Some(Continue)
    });
    p.complete(_marker, SWITCH_CASE);
    _ok
}

pub fn labeled_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        identifier(p)?;
        p.expect(COLON)?;
        statement(p)?;
        Some(Continue)
    });
    p.complete(_marker, LABELED_STATEMENT);
    _ok
}

pub fn throw_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(THROW_KW)?;
        if !(!p.at_line_terminator()) {
            p.error("expected to be not at line terminator")?;
        }
        expression_list(p)?;
        eos(p)?;
        Some(Continue)
    });
    p.complete(_marker, THROW_STATEMENT);
    _ok
}

pub fn try_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(TRY_KW)?;
        block(p)?;
        if p.at(CATCH_KW) {
            catch_clause(p)?;
            if p.at(FINALLY_KW) {
                finally_clause(p)?;
            }
        } else if p.at(FINALLY_KW) {
            finally_clause(p)?;
        } else {
            p.expected_ts_in("try_statement", &tokenset![CATCH_KW, FINALLY_KW])?;
        }
        Some(Continue)
    });
    p.complete(_marker, TRY_STATEMENT);
    _ok
}

pub fn catch_clause(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(CATCH_KW)?;
        p.expect(L_PAREN)?;
        identifier_pattern(p)?;
        p.expect(R_PAREN)?;
        block(p)?;
        Some(Continue)
    });
    p.complete(_marker, CATCH_CLAUSE);
    _ok
}

pub fn finally_clause(p: &mut Parser) -> Option<Continue> {
    p.expect(FINALLY_KW)?;
    block(p)?;
    Some(Continue)
}

pub fn debugger_statement(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(DEBUGGER_KW)?;
        eos(p)?;
        Some(Continue)
    });
    p.complete(_marker, DEBUGGER_STATEMENT);
    _ok
}

pub fn function_declaration(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if p.at_keyword("async") && p.at(IDENTIFIER) {
            async_kw(p)?;
            p.expect(FUNCTION_KW)?;
        } else if p.at(FUNCTION_KW) {
            p.bump();
            p.eat(ASTERISK);
        } else {
            p.expected_ts_in("function_declaration", &tokenset![FUNCTION_KW, IDENTIFIER])?;
        }
        identifier(p)?;
        function_parameters(p)?;
        function_body(p)?;
        Some(Continue)
    });
    p.complete(_marker, FUNCTION_DECLARATION);
    _ok
}

pub fn class_declaration(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(CLASS_KW)?;
        identifier(p)?;
        class_tail(p)?;
        Some(Continue)
    });
    p.complete(_marker, CLASS_DECLARATION);
    _ok
}

pub fn class_tail(p: &mut Parser) -> Option<Continue> {
    if p.at(EXTENDS_KW) {
        p.bump();
        expression(p)?;
    }
    class_body(p)?;
    Some(Continue)
}

pub fn class_body(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_CURLY)?;
        while p.at_ts(&AT_CLASS_ELEMENT) {
            let mut _checkpoint = p.checkpoint(true);
            class_element(p);
            if !p.commit(_checkpoint)?.is_ok() {
                break;
            }
        }
        p.expect(R_CURLY)?;
        Some(Continue)
    });
    p.complete(_marker, CLASS_BODY);
    _ok
}

pub fn class_element(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&AT_METHOD_DEFINITION) {
        method_definition(p)?;
    } else if p.at(SEMICOLON) {
        empty_statement(p)?;
    } else {
        p.expected_ts_in("class_element", &AT_CLASS_ELEMENT)?;
    }
    Some(Continue)
}

pub fn method_definition(p: &mut Parser) -> Option<Continue> {
    let mut _checkpoint = p.checkpoint(false);
    let _marker = p.start();
    p.eat(STATIC_KW);
    if p.at_ts(&AT_PROPERTY_NAME) && {
        // try --> property_name method_tail #METHOD_DEFINITION
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            property_name(p)?;
            method_tail(p)?;
            p.complete(_checkpoint.branch(&_marker), METHOD_DEFINITION);
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if (p.at_keyword("get") && p.at(IDENTIFIER)) && {
        // try --> getter getter_tail #METHOD_DEFINITION
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            getter(p)?;
            getter_tail(p)?;
            p.complete(_checkpoint.branch(&_marker), METHOD_DEFINITION);
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if (p.at_keyword("set") && p.at(IDENTIFIER)) && {
        // try --> setter setter_tail #METHOD_DEFINITION
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            setter(p)?;
            setter_tail(p)?;
            p.complete(_checkpoint.branch(&_marker), METHOD_DEFINITION);
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at_ts(&AT_GENERATOR_METHOD) {
        generator_method(p)?;
        p.complete(_checkpoint.branch(&_marker), METHOD_DEFINITION);
    } else {
        // otherwise, emit an error
        p.expected_ts_in("method_definition", &AT_METHOD_DEFINITION)?;
    }
    Some(Continue)
}

pub fn method_tail(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        function_parameters(p)?;
        function_body(p)?;
        Some(Continue)
    });
    p.complete(_marker, FUNCTION_EXPRESSION);
    _ok
}

pub fn generator_method(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if p.at(ASTERISK) || (p.at_keyword("async") && p.at(IDENTIFIER)) {
            if p.at(ASTERISK) {
                p.bump();
            } else if p.at_keyword("async") && p.at(IDENTIFIER) {
                async_kw(p)?;
            }
        }
        identifier_or_keyword(p)?;
        function_parameters(p)?;
        function_body(p)?;
        Some(Continue)
    });
    p.complete(_marker, FUNCTION_EXPRESSION);
    _ok
}

pub fn formal_parameter_list(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&tokenset![IDENTIFIER, L_CURLY, L_SQUARE]) && {
        // try --> formal_parameter (, formal_parameter)* (, formal_parameter_rest)?
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            formal_parameter(p)?;
            while p.at(COMMA) {
                let mut _checkpoint = p.checkpoint(true);
                catch!({
                    p.bump();
                    formal_parameter(p)?;
                    Some(Continue)
                });
                if !p.commit(_checkpoint)?.is_ok() {
                    break;
                }
            }
            if p.at(COMMA) {
                p.bump();
                formal_parameter_rest(p)?;
            }
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(DOTDOTDOT) {
        formal_parameter_rest(p)?;
    } else if p.at(L_SQUARE) {
        array_pattern(p)?;
    } else if p.at(L_CURLY) {
        object_pattern(p)?;
    } else {
        // otherwise, emit an error
        p.expected_ts_in("formal_parameter_list", &tokenset![DOTDOTDOT, IDENTIFIER, L_CURLY, L_SQUARE])?;
    }
    Some(Continue)
}

pub fn formal_parameter(p: &mut Parser) -> Option<Continue> {
    if p.at(L_SQUARE) {
        array_pattern(p)?;
    } else if p.at(L_CURLY) {
        object_pattern(p)?;
    } else if p.at(IDENTIFIER) {
        identifier_pattern(p)?;
    } else {
        p.expected_ts_in("formal_parameter", &tokenset![IDENTIFIER, L_CURLY, L_SQUARE])?;
    }
    Some(Continue)
}

pub fn formal_parameter_rest(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(DOTDOTDOT)?;
        identifier_pattern(p)?;
        Some(Continue)
    });
    p.complete(_marker, REST_ELEMENT);
    _ok
}

pub fn function_body(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_CURLY)?;
        if p.at_ts(&_TS0) || (!p.at(L_CURLY) && !p.at(FUNCTION_KW) && p.at_ts(&_TS1)) {
            source_elements(p)?;
        }
        p.expect(R_CURLY)?;
        Some(Continue)
    });
    p.complete(_marker, BLOCK_STATEMENT);
    _ok
}

pub fn source_elements(p: &mut Parser) -> Option<Continue> {
    source_element(p)?;
    while p.at_ts(&_TS0) || (!p.at(L_CURLY) && !p.at(FUNCTION_KW) && p.at_ts(&_TS1)) {
        let mut _checkpoint = p.checkpoint(true);
        source_element(p);
        if !p.commit(_checkpoint)?.is_ok() {
            break;
        }
    }
    Some(Continue)
}

pub fn array_expression(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_SQUARE)?;
        while p.eat(COMMA) {}
        if p.at_ts(&AT_ELEMENT_OR_SPREAD) {
            element_list(p)?;
        }
        while p.eat(COMMA) {}
        p.expect(R_SQUARE)?;
        Some(Continue)
    });
    p.complete(_marker, ARRAY_EXPRESSION);
    _ok
}

pub fn element_list(p: &mut Parser) -> Option<Continue> {
    element_or_spread(p)?;
    while p.at(COMMA) {
        p.bump();
        while p.eat(COMMA) {}
        element_or_spread(p)?;
    }
    Some(Continue)
}

pub fn element_or_spread(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&AT_EXPRESSION_LIST_OR_EXPRESSION) {
        expression(p)?;
    } else if p.at(DOTDOTDOT) {
        spread_expression(p)?;
    } else {
        p.expected_ts_in("element_or_spread", &AT_ELEMENT_OR_SPREAD)?;
    }
    Some(Continue)
}

pub fn object_expression(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_CURLY)?;
        if p.at_ts(&AT_PROPERTY_OR_SPREAD) {
            property_list(p)?;
        }
        p.eat(COMMA);
        p.expect(R_CURLY)?;
        Some(Continue)
    });
    p.complete(_marker, OBJECT_EXPRESSION);
    _ok
}

pub fn property_list(p: &mut Parser) -> Option<Continue> {
    property_or_spread(p)?;
    while p.at(COMMA) {
        p.bump();
        property_or_spread(p)?;
    }
    Some(Continue)
}

pub fn property_or_spread(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&AT_PROPERTY) {
        property(p)?;
    } else if p.at(DOTDOTDOT) {
        spread_expression(p)?;
    } else {
        p.expected_ts_in("property_or_spread", &AT_PROPERTY_OR_SPREAD)?;
    }
    Some(Continue)
}

pub fn spread_expression(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(DOTDOTDOT)?;
        expression(p)?;
        Some(Continue)
    });
    p.complete(_marker, SPREAD_ELEMENT);
    _ok
}

pub fn pattern(p: &mut Parser) -> Option<Continue> {
    if p.at(L_CURLY) {
        object_pattern(p)?;
    } else if p.at(L_SQUARE) {
        array_pattern(p)?;
    } else if p.at(DOTDOTDOT) {
        spread_pattern(p)?;
    } else if p.at(IDENTIFIER) {
        identifier_pattern(p)?;
    } else {
        p.expected_ts_in("pattern", &tokenset![DOTDOTDOT, IDENTIFIER, L_CURLY, L_SQUARE])?;
    }
    Some(Continue)
}

pub fn assignment_property(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&AT_IDENTIFIER_OR_KEYWORD) && {
        // try --> identifier_or_keyword : pattern #PROPERTY
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            let _marker = p.start();
            let _ok = catch!({
                identifier_or_keyword(p)?;
                p.expect(COLON)?;
                pattern(p)?;
                Some(Continue)
            });
            p.complete(_marker, PROPERTY);
            if _ok.is_none() {
                return None;
            }
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(L_SQUARE) {
        let _marker = p.start();
        let _ok = catch!({
            p.bump();
            expression(p)?;
            p.expect(R_SQUARE)?;
            p.expect(COLON)?;
            pattern(p)?;
            Some(Continue)
        });
        p.complete(_marker, PROPERTY);
        if _ok.is_none() {
            return None;
        }
    } else if p.at(IDENTIFIER) {
        let _marker = p.start();
        let _ok = identifier(p);
        p.complete(_marker, PROPERTY);
        if _ok.is_none() {
            return None;
        }
    } else {
        // otherwise, emit an error
        p.expected_ts_in("assignment_property", &AT_INTERFACE_PROPERTY_OR_ASSIGNMENT_PROPERTY)?;
    }
    Some(Continue)
}

pub fn spread_pattern(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(DOTDOTDOT)?;
        if p.at(IDENTIFIER) {
            identifier(p)?;
        }
        Some(Continue)
    });
    p.complete(_marker, SPREAD_ELEMENT);
    _ok
}

pub fn identifier(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = p.expect(IDENTIFIER);
    p.complete(_marker, IDENTIFIER);
    _ok
}

pub fn property(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&AT_PROPERTY_NAME) && {
        // try --> property_name : expression #PROPERTY
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            let _marker = p.start();
            let _ok = catch!({
                property_name(p)?;
                p.expect(COLON)?;
                expression(p)?;
                Some(Continue)
            });
            p.complete(_marker, PROPERTY);
            if _ok.is_none() {
                return None;
            }
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(L_SQUARE) {
        let _marker = p.start();
        let _ok = catch!({
            p.bump();
            expression(p)?;
            p.expect(R_SQUARE)?;
            p.expect(COLON)?;
            expression(p)?;
            Some(Continue)
        });
        p.complete(_marker, PROPERTY);
        if _ok.is_none() {
            return None;
        }
    } else if (p.at_keyword("get") && p.at(IDENTIFIER)) && {
        // try --> getter getter_tail #PROPERTY
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            let _marker = p.start();
            let _ok = catch!({
                getter(p)?;
                getter_tail(p)?;
                Some(Continue)
            });
            p.complete(_marker, PROPERTY);
            if _ok.is_none() {
                return None;
            }
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if (p.at_keyword("set") && p.at(IDENTIFIER)) && {
        // try --> setter setter_tail #PROPERTY
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            let _marker = p.start();
            let _ok = catch!({
                setter(p)?;
                setter_tail(p)?;
                Some(Continue)
            });
            p.complete(_marker, PROPERTY);
            if _ok.is_none() {
                return None;
            }
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at_ts(&AT_GENERATOR_METHOD) && {
        // try --> generator_method #PROPERTY
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            let _marker = p.start();
            let _ok = generator_method(p);
            p.complete(_marker, PROPERTY);
            if _ok.is_none() {
                return None;
            }
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(IDENTIFIER) {
        let _marker = p.start();
        let _ok = identifier(p);
        p.complete(_marker, PROPERTY);
        if _ok.is_none() {
            return None;
        }
    } else {
        // otherwise, emit an error
        p.expected_ts_in("property", &AT_PROPERTY)?;
    }
    Some(Continue)
}

pub fn property_name(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&AT_IDENTIFIER_OR_KEYWORD) {
        identifier_or_keyword(p)?;
    } else if p.at(STRING_LITERAL) {
        let _marker = p.start();
        p.bump();
        p.complete(_marker, LITERAL);
    } else if p.at(NUMBER_LITERAL) {
        let _marker = p.start();
        p.bump();
        p.complete(_marker, LITERAL);
    } else {
        p.expected_ts_in("property_name", &AT_PROPERTY_NAME)?;
    }
    Some(Continue)
}

pub fn getter_tail(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_PAREN)?;
        p.expect(R_PAREN)?;
        function_body(p)?;
        Some(Continue)
    });
    p.complete(_marker, FUNCTION_EXPRESSION);
    _ok
}

pub fn setter_tail(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_PAREN)?;
        identifier_pattern(p)?;
        p.expect(R_PAREN)?;
        function_body(p)?;
        Some(Continue)
    });
    p.complete(_marker, FUNCTION_EXPRESSION);
    _ok
}

pub fn arguments(p: &mut Parser) -> Option<Continue> {
    p.expect(L_PAREN)?;
    if p.at_ts(&AT_ELEMENT_OR_SPREAD) {
        if p.at_ts(&AT_EXPRESSION_LIST_OR_EXPRESSION) {
            expression(p)?;
            while p.at(COMMA) {
                let mut _checkpoint = p.checkpoint(true);
                catch!({
                    p.bump();
                    expression(p)?;
                    Some(Continue)
                });
                if !p.commit(_checkpoint)?.is_ok() {
                    break;
                }
            }
            if p.at(COMMA) {
                p.bump();
                last_argument(p)?;
            }
        } else if p.at(DOTDOTDOT) {
            last_argument(p)?;
        }
    }
    p.expect(R_PAREN)?;
    Some(Continue)
}

pub fn last_argument(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(DOTDOTDOT)?;
        identifier(p)?;
        Some(Continue)
    });
    p.complete(_marker, SPREAD_ELEMENT);
    _ok
}

pub fn expression_list(p: &mut Parser) -> Option<Continue> {
    let mut _checkpoint = p.checkpoint(false);
    let _marker = p.start();
    expression(p)?;
    if p.at(COMMA) {
        if p.at(COMMA) {
            p.bump();
            expression(p)?;
            while p.at(COMMA) {
                p.bump();
                expression(p)?;
            }
            p.complete(_checkpoint.branch(&_marker), SEQUENCE_EXPRESSION);
        }
    }
    Some(Continue)
}

pub fn class_expression(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(CLASS_KW)?;
        if p.at(IDENTIFIER) {
            identifier(p)?;
        }
        class_tail(p)?;
        Some(Continue)
    });
    p.complete(_marker, CLASS_EXPRESSION);
    _ok
}

pub fn function_expression(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(FUNCTION_KW)?;
        if p.at(IDENTIFIER) {
            identifier(p)?;
        }
        function_parameters(p)?;
        function_body(p)?;
        Some(Continue)
    });
    p.complete(_marker, FUNCTION_EXPRESSION);
    _ok
}

pub fn arrow_function_expression(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if p.at_keyword("async") && p.at(IDENTIFIER) {
            async_kw(p)?;
        }
        arrow_function_parameters(p)?;
        p.expect(FAT_ARROW)?;
        arrow_function_body(p)?;
        Some(Continue)
    });
    p.complete(_marker, ARROW_FUNCTION_EXPRESSION);
    _ok
}

pub fn arrow_function_parameters(p: &mut Parser) -> Option<Continue> {
    if p.at(L_PAREN) {
        function_parameters(p)?;
    } else if p.at(IDENTIFIER) {
        identifier_pattern(p)?;
    } else {
        p.expected_ts_in("arrow_function_parameters", &tokenset![IDENTIFIER, L_PAREN])?;
    }
    Some(Continue)
}

pub fn arrow_function_body(p: &mut Parser) -> Option<Continue> {
    if p.at(L_CURLY) && {
        // try --> function_body
        let mut _checkpoint = p.checkpoint(true);
        function_body(p);
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at_ts(&AT_EXPRESSION_LIST_OR_EXPRESSION) {
        expression(p)?;
    } else {
        // otherwise, emit an error
        p.expected_ts_in("arrow_function_body", &AT_EXPRESSION_LIST_OR_EXPRESSION)?;
    }
    Some(Continue)
}

pub fn assignment_operator(p: &mut Parser) -> Option<Continue> {
    p.expect_ts(&AT_ASSIGNMENT_OPERATOR)
}

pub fn literal(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = p.expect_ts(&AT_LITERAL);
    p.complete(_marker, LITERAL);
    _ok
}

pub fn identifier_or_keyword(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if p.at(IDENTIFIER) {
            p.bump();
        } else if p.at_ts(&AT_RESERVED_WORD) {
            reserved_word(p)?;
        } else {
            p.expected_ts_in("identifier_or_keyword", &AT_IDENTIFIER_OR_KEYWORD)?;
        }
        Some(Continue)
    });
    p.complete(_marker, IDENTIFIER);
    _ok
}

pub fn reserved_word(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&AT_KEYWORD) {
        keyword(p)?;
    } else if p.at(NULL_KW) {
        p.bump();
    } else if p.at(TRUE_KW) {
        p.bump();
    } else if p.at(FALSE_KW) {
        p.bump();
    } else {
        p.expected_ts_in("reserved_word", &AT_RESERVED_WORD)?;
    }
    Some(Continue)
}

pub fn keyword(p: &mut Parser) -> Option<Continue> {
    p.expect_ts(&AT_KEYWORD)
}

pub fn getter(p: &mut Parser) -> Option<Continue> {
    get_kw(p)?;
    property_name(p)?;
    Some(Continue)
}

pub fn setter(p: &mut Parser) -> Option<Continue> {
    set_kw(p)?;
    property_name(p)?;
    Some(Continue)
}

pub fn as_kw(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if !(p.at_keyword("as")) {
            p.error("expected to be at keyword 'as'")?;
        }
        p.expect(IDENTIFIER)?;
        Some(Continue)
    });
    p.complete(_marker, AS_KW);
    _ok
}

pub fn from_kw(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if !(p.at_keyword("from")) {
            p.error("expected to be at keyword 'from'")?;
        }
        p.expect(IDENTIFIER)?;
        Some(Continue)
    });
    p.complete(_marker, FROM_KW);
    _ok
}

pub fn get_kw(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if !(p.at_keyword("get")) {
            p.error("expected to be at keyword 'get'")?;
        }
        p.expect(IDENTIFIER)?;
        Some(Continue)
    });
    p.complete(_marker, GET_KW);
    _ok
}

pub fn set_kw(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if !(p.at_keyword("set")) {
            p.error("expected to be at keyword 'set'")?;
        }
        p.expect(IDENTIFIER)?;
        Some(Continue)
    });
    p.complete(_marker, SET_KW);
    _ok
}

pub fn of_kw(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if !(p.at_keyword("of")) {
            p.error("expected to be at keyword 'of'")?;
        }
        p.expect(IDENTIFIER)?;
        Some(Continue)
    });
    p.complete(_marker, OF_KW);
    _ok
}

pub fn async_kw(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        if !(p.at_keyword("async")) {
            p.error("expected to be at keyword 'async'")?;
        }
        p.expect(IDENTIFIER)?;
        Some(Continue)
    });
    p.complete(_marker, ASYNC_KW);
    _ok
}

pub fn eos(p: &mut Parser) -> Option<Continue> {
    if p.at(SEMICOLON) {
        p.bump();
    } else if p.at(EOF) {
        p.bump();
    } else if p.at_line_terminator() {
    } else if p.at(R_CURLY) {
    } else {
        p.expected_ts_in("eos", &tokenset![EOF, SEMICOLON])?;
    }
    Some(Continue)
}

pub(crate) const AT_ASSIGNMENT_OPERATOR: TokenSet = tokenset![AMPERSAND_EQ, ASTERISK_EQ, CARET_EQ, EQ, MINUS_EQ, PERCENT_EQ, PIPE_EQ, PLUS_EQ, SHL_EQ, SHR_EQ, SHU_EQ, SLASH_EQ];
pub(crate) const AT_CLASS_ELEMENT: TokenSet = tokenset![ASTERISK, BREAK_KW, CASE_KW, CATCH_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DEFAULT_KW, DELETE_KW, DO_KW, ELSE_KW, ENUM_KW, EXPORT_KW, EXTENDS_KW, FALSE_KW, FINALLY_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, IMPLEMENTS_KW, IMPORT_KW, INSTANCEOF_KW, INTERFACE_KW, IN_KW, LET_KW, NEW_KW, NULL_KW, NUMBER_LITERAL, PACKAGE_KW, PRIVATE_KW, PROTECTED_KW, PUBLIC_KW, RETURN_KW, SEMICOLON, STATIC_KW, STRING_LITERAL, SUPER_KW, SWITCH_KW, THIS_KW, THROW_KW, TRUE_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
pub(crate) const AT_ELEMENT_OR_SPREAD: TokenSet = tokenset![AWAIT_KW, BANG, CLASS_KW, DECREMENT, DELETE_KW, DOTDOTDOT, FALSE_KW, FUNCTION_KW, IDENTIFIER, INCREMENT, L_CURLY, L_PAREN, L_SQUARE, MINUS, NEW_KW, NULL_KW, NUMBER_LITERAL, PLUS, REGEXP_LITERAL, STRING_LITERAL, SUPER_KW, TEMPLATE_LITERAL, THIS_KW, TILDE, TRUE_KW, TYPEOF_KW, VOID_KW, YIELD_KW];
pub(crate) const AT_EXPRESSION_LIST_OR_EXPRESSION: TokenSet = tokenset![AWAIT_KW, BANG, CLASS_KW, DECREMENT, DELETE_KW, FALSE_KW, FUNCTION_KW, IDENTIFIER, INCREMENT, L_CURLY, L_PAREN, L_SQUARE, MINUS, NEW_KW, NULL_KW, NUMBER_LITERAL, PLUS, REGEXP_LITERAL, STRING_LITERAL, SUPER_KW, TEMPLATE_LITERAL, THIS_KW, TILDE, TRUE_KW, TYPEOF_KW, VOID_KW, YIELD_KW];
pub(crate) const AT_GENERATOR_METHOD: TokenSet = tokenset![ASTERISK, BREAK_KW, CASE_KW, CATCH_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DEFAULT_KW, DELETE_KW, DO_KW, ELSE_KW, ENUM_KW, EXPORT_KW, EXTENDS_KW, FALSE_KW, FINALLY_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, IMPLEMENTS_KW, IMPORT_KW, INSTANCEOF_KW, INTERFACE_KW, IN_KW, LET_KW, NEW_KW, NULL_KW, PACKAGE_KW, PRIVATE_KW, PROTECTED_KW, PUBLIC_KW, RETURN_KW, STATIC_KW, SUPER_KW, SWITCH_KW, THIS_KW, THROW_KW, TRUE_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
pub(crate) const AT_IDENTIFIER_OR_KEYWORD: TokenSet = tokenset![BREAK_KW, CASE_KW, CATCH_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DEFAULT_KW, DELETE_KW, DO_KW, ELSE_KW, ENUM_KW, EXPORT_KW, EXTENDS_KW, FALSE_KW, FINALLY_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, IMPLEMENTS_KW, IMPORT_KW, INSTANCEOF_KW, INTERFACE_KW, IN_KW, LET_KW, NEW_KW, NULL_KW, PACKAGE_KW, PRIVATE_KW, PROTECTED_KW, PUBLIC_KW, RETURN_KW, STATIC_KW, SUPER_KW, SWITCH_KW, THIS_KW, THROW_KW, TRUE_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
pub(crate) const AT_INTERFACE_PROPERTY_OR_ASSIGNMENT_PROPERTY: TokenSet = tokenset![BREAK_KW, CASE_KW, CATCH_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DEFAULT_KW, DELETE_KW, DO_KW, ELSE_KW, ENUM_KW, EXPORT_KW, EXTENDS_KW, FALSE_KW, FINALLY_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, IMPLEMENTS_KW, IMPORT_KW, INSTANCEOF_KW, INTERFACE_KW, IN_KW, LET_KW, L_SQUARE, NEW_KW, NULL_KW, PACKAGE_KW, PRIVATE_KW, PROTECTED_KW, PUBLIC_KW, RETURN_KW, STATIC_KW, SUPER_KW, SWITCH_KW, THIS_KW, THROW_KW, TRUE_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
pub(crate) const AT_KEYWORD: TokenSet = tokenset![BREAK_KW, CASE_KW, CATCH_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DEFAULT_KW, DELETE_KW, DO_KW, ELSE_KW, ENUM_KW, EXPORT_KW, EXTENDS_KW, FINALLY_KW, FOR_KW, FUNCTION_KW, IF_KW, IMPLEMENTS_KW, IMPORT_KW, INSTANCEOF_KW, INTERFACE_KW, IN_KW, LET_KW, NEW_KW, PACKAGE_KW, PRIVATE_KW, PROTECTED_KW, PUBLIC_KW, RETURN_KW, STATIC_KW, SUPER_KW, SWITCH_KW, THIS_KW, THROW_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
pub(crate) const AT_LITERAL: TokenSet = tokenset![FALSE_KW, NULL_KW, NUMBER_LITERAL, REGEXP_LITERAL, STRING_LITERAL, TEMPLATE_LITERAL, TRUE_KW];
pub(crate) const AT_METHOD_DEFINITION: TokenSet = tokenset![ASTERISK, BREAK_KW, CASE_KW, CATCH_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DEFAULT_KW, DELETE_KW, DO_KW, ELSE_KW, ENUM_KW, EXPORT_KW, EXTENDS_KW, FALSE_KW, FINALLY_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, IMPLEMENTS_KW, IMPORT_KW, INSTANCEOF_KW, INTERFACE_KW, IN_KW, LET_KW, NEW_KW, NULL_KW, NUMBER_LITERAL, PACKAGE_KW, PRIVATE_KW, PROTECTED_KW, PUBLIC_KW, RETURN_KW, STATIC_KW, STRING_LITERAL, SUPER_KW, SWITCH_KW, THIS_KW, THROW_KW, TRUE_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
pub(crate) const AT_PROPERTY: TokenSet = tokenset![ASTERISK, BREAK_KW, CASE_KW, CATCH_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DEFAULT_KW, DELETE_KW, DO_KW, ELSE_KW, ENUM_KW, EXPORT_KW, EXTENDS_KW, FALSE_KW, FINALLY_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, IMPLEMENTS_KW, IMPORT_KW, INSTANCEOF_KW, INTERFACE_KW, IN_KW, LET_KW, L_SQUARE, NEW_KW, NULL_KW, NUMBER_LITERAL, PACKAGE_KW, PRIVATE_KW, PROTECTED_KW, PUBLIC_KW, RETURN_KW, STATIC_KW, STRING_LITERAL, SUPER_KW, SWITCH_KW, THIS_KW, THROW_KW, TRUE_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
pub(crate) const AT_PROPERTY_NAME: TokenSet = tokenset![BREAK_KW, CASE_KW, CATCH_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DEFAULT_KW, DELETE_KW, DO_KW, ELSE_KW, ENUM_KW, EXPORT_KW, EXTENDS_KW, FALSE_KW, FINALLY_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, IMPLEMENTS_KW, IMPORT_KW, INSTANCEOF_KW, INTERFACE_KW, IN_KW, LET_KW, NEW_KW, NULL_KW, NUMBER_LITERAL, PACKAGE_KW, PRIVATE_KW, PROTECTED_KW, PUBLIC_KW, RETURN_KW, STATIC_KW, STRING_LITERAL, SUPER_KW, SWITCH_KW, THIS_KW, THROW_KW, TRUE_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
pub(crate) const AT_PROPERTY_OR_SPREAD: TokenSet = tokenset![ASTERISK, BREAK_KW, CASE_KW, CATCH_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DEFAULT_KW, DELETE_KW, DOTDOTDOT, DO_KW, ELSE_KW, ENUM_KW, EXPORT_KW, EXTENDS_KW, FALSE_KW, FINALLY_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, IMPLEMENTS_KW, IMPORT_KW, INSTANCEOF_KW, INTERFACE_KW, IN_KW, LET_KW, L_SQUARE, NEW_KW, NULL_KW, NUMBER_LITERAL, PACKAGE_KW, PRIVATE_KW, PROTECTED_KW, PUBLIC_KW, RETURN_KW, STATIC_KW, STRING_LITERAL, SUPER_KW, SWITCH_KW, THIS_KW, THROW_KW, TRUE_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
pub(crate) const AT_RESERVED_WORD: TokenSet = tokenset![BREAK_KW, CASE_KW, CATCH_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DEFAULT_KW, DELETE_KW, DO_KW, ELSE_KW, ENUM_KW, EXPORT_KW, EXTENDS_KW, FALSE_KW, FINALLY_KW, FOR_KW, FUNCTION_KW, IF_KW, IMPLEMENTS_KW, IMPORT_KW, INSTANCEOF_KW, INTERFACE_KW, IN_KW, LET_KW, NEW_KW, NULL_KW, PACKAGE_KW, PRIVATE_KW, PROTECTED_KW, PUBLIC_KW, RETURN_KW, STATIC_KW, SUPER_KW, SWITCH_KW, THIS_KW, THROW_KW, TRUE_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
pub(crate) const AT_SOURCE_ELEMENT: TokenSet = tokenset![AWAIT_KW, BANG, BREAK_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DECREMENT, DELETE_KW, DO_KW, ENUM_KW, EXPORT_KW, FALSE_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, IMPORT_KW, INCREMENT, INTERFACE_KW, LET_KW, L_CURLY, L_PAREN, L_SQUARE, MINUS, NEW_KW, NULL_KW, NUMBER_LITERAL, PLUS, REGEXP_LITERAL, RETURN_KW, SEMICOLON, STRING_LITERAL, SUPER_KW, SWITCH_KW, TEMPLATE_LITERAL, THIS_KW, THROW_KW, TILDE, TRUE_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
pub(crate) const AT_STATEMENT: TokenSet = tokenset![AWAIT_KW, BANG, BREAK_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DECREMENT, DELETE_KW, DO_KW, ENUM_KW, FALSE_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, INCREMENT, INTERFACE_KW, LET_KW, L_CURLY, L_PAREN, L_SQUARE, MINUS, NEW_KW, NULL_KW, NUMBER_LITERAL, PLUS, REGEXP_LITERAL, RETURN_KW, SEMICOLON, STRING_LITERAL, SUPER_KW, SWITCH_KW, TEMPLATE_LITERAL, THIS_KW, THROW_KW, TILDE, TRUE_KW, TRY_KW, TYPEOF_KW, VAR_KW, VOID_KW, WHILE_KW, WITH_KW, YIELD_KW];
pub(crate) const AT_TYPE_EXPR: TokenSet = tokenset![BOOLEAN_KW, FALSE_KW, IDENTIFIER, L_CURLY, L_PAREN, L_SQUARE, NULL_KW, NUMBER_LITERAL, REGEXP_LITERAL, STRING_LITERAL, TEMPLATE_LITERAL, TRUE_KW, TYPEOF_KW];
pub(crate) const _TS0: TokenSet = tokenset![BREAK_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DO_KW, ENUM_KW, EXPORT_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, IMPORT_KW, INTERFACE_KW, LET_KW, L_CURLY, RETURN_KW, SEMICOLON, SWITCH_KW, THROW_KW, TRY_KW, VAR_KW, WHILE_KW, WITH_KW];
pub(crate) const _TS1: TokenSet = tokenset![AWAIT_KW, BANG, DECREMENT, DELETE_KW, FALSE_KW, INCREMENT, L_PAREN, L_SQUARE, MINUS, NEW_KW, NULL_KW, NUMBER_LITERAL, PLUS, REGEXP_LITERAL, STRING_LITERAL, SUPER_KW, TEMPLATE_LITERAL, THIS_KW, TILDE, TRUE_KW, TYPEOF_KW, VOID_KW, YIELD_KW];
pub(crate) const _TS2: TokenSet = tokenset![ASTERISK, CONST_KW, DEFAULT_KW, ENUM_KW, IDENTIFIER, INTERFACE_KW, LET_KW, L_CURLY, VAR_KW];
pub(crate) const _TS3: TokenSet = tokenset![BREAK_KW, CLASS_KW, CONST_KW, CONTINUE_KW, DEBUGGER_KW, DO_KW, ENUM_KW, FOR_KW, FUNCTION_KW, IDENTIFIER, IF_KW, INTERFACE_KW, LET_KW, L_CURLY, RETURN_KW, SEMICOLON, SWITCH_KW, THROW_KW, TRY_KW, VAR_KW, WHILE_KW, WITH_KW];
pub(crate) const _TS4: TokenSet = tokenset![AWAIT_KW, BANG, CLASS_KW, DECREMENT, DELETE_KW, FALSE_KW, FUNCTION_KW, IDENTIFIER, INCREMENT, L_CURLY, L_PAREN, L_SQUARE, MINUS, NEW_KW, NULL_KW, NUMBER_LITERAL, PLUS, REGEXP_LITERAL, SEMICOLON, STRING_LITERAL, SUPER_KW, TEMPLATE_LITERAL, THIS_KW, TILDE, TRUE_KW, TYPEOF_KW, VOID_KW, YIELD_KW];
pub(crate) const _TS5: TokenSet = tokenset![AWAIT_KW, BANG, CLASS_KW, CONST_KW, DECREMENT, DELETE_KW, FALSE_KW, FUNCTION_KW, IDENTIFIER, INCREMENT, LET_KW, L_CURLY, L_PAREN, L_SQUARE, MINUS, NEW_KW, NULL_KW, NUMBER_LITERAL, PLUS, REGEXP_LITERAL, SEMICOLON, STRING_LITERAL, SUPER_KW, TEMPLATE_LITERAL, THIS_KW, TILDE, TRUE_KW, TYPEOF_KW, VAR_KW, VOID_KW, YIELD_KW];

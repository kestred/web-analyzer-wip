// This file is automatically generated by running `cargo run -p antlr_codegen`.
//
// =====================
// Do not edit manually.
// =====================
//
#![allow(dead_code)]
#![allow(unused_imports)]

//! This module contains an auto-generated VUE parser.
use crate::syntax_kind::*;
use code_grammar::{catch, tokenset, Parser, TokenSet};
use code_grammar::parser::Continue;

pub fn component(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        while p.at_ts(&tokenset![COMMENT, L_ANGLE, TEXT, WHITESPACE]) {
            component_pattern(p)?;
        }
        Some(Continue)
    });
    p.complete(_marker, COMPONENT);
    _ok
}

pub fn component_pattern(p: &mut Parser) -> Option<Continue> {
    if p.at(L_ANGLE) && {
        // try --> component_template
        let mut _checkpoint = p.checkpoint(true);
        component_template(p);
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(L_ANGLE) && {
        // try --> component_script
        let mut _checkpoint = p.checkpoint(true);
        component_script(p);
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(L_ANGLE) {
        component_style(p)?;
    } else if p.at_ts(&tokenset![COMMENT, TEXT, WHITESPACE]) {
        html_misc(p)?;
    } else {
        // otherwise, emit an error
        p.expected_ts_in("component_pattern", &tokenset![COMMENT, L_ANGLE, TEXT, WHITESPACE])?;
    }
    Some(Continue)
}

pub fn component_template(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_ANGLE)?;
        template_tag(p)?;
        p.eat(WS);
        while p.at_ts(&tokenset![AT, COLON, TAG_NAME]) {
            attribute(p)?;
            p.eat(WS);
        }
        p.expect(R_ANGLE)?;
        template_content(p)?;
        if p.at(L_ANGLE) {
            p.bump();
            p.expect(SLASH)?;
        } else if p.at(L_ANGLE_SLASH) {
            p.bump();
        } else {
            p.expected_ts_in("component_template", &tokenset![L_ANGLE, L_ANGLE_SLASH])?;
        }
        p.eat(WS);
        template_tag(p)?;
        p.eat(WS);
        p.expect(R_ANGLE)?;
        Some(Continue)
    });
    p.complete(_marker, COMPONENT_TEMPLATE);
    _ok
}

pub fn component_script(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_ANGLE)?;
        script_tag(p)?;
        p.eat(WS);
        while p.at_ts(&tokenset![AT, COLON, TAG_NAME]) {
            attribute(p)?;
            p.eat(WS);
        }
        p.expect(R_ANGLE)?;
        script_block(p)?;
        if p.at(L_ANGLE) {
            p.bump();
            p.expect(SLASH)?;
        } else if p.at(L_ANGLE_SLASH) {
            p.bump();
        } else {
            p.expected_ts_in("component_script", &tokenset![L_ANGLE, L_ANGLE_SLASH])?;
        }
        p.eat(WS);
        script_tag(p)?;
        p.eat(WS);
        p.expect(R_ANGLE)?;
        Some(Continue)
    });
    p.complete(_marker, COMPONENT_SCRIPT);
    _ok
}

pub fn component_style(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(L_ANGLE)?;
        style_tag(p)?;
        p.eat(WS);
        while p.at_ts(&tokenset![AT, COLON, TAG_NAME]) {
            attribute(p)?;
            p.eat(WS);
        }
        p.expect(R_ANGLE)?;
        style_block(p)?;
        if p.at(L_ANGLE) {
            p.bump();
            p.expect(SLASH)?;
        } else if p.at(L_ANGLE_SLASH) {
            p.bump();
        } else {
            p.expected_ts_in("component_style", &tokenset![L_ANGLE, L_ANGLE_SLASH])?;
        }
        p.eat(WS);
        style_tag(p)?;
        p.eat(WS);
        p.expect(R_ANGLE)?;
        Some(Continue)
    });
    p.complete(_marker, COMPONENT_STYLE);
    _ok
}

pub fn template_tag(p: &mut Parser) -> Option<Continue> {
    if !(p.at_keyword("template")) {
        p.error("expected to be at keyword 'template'")?;
    }
    p.expect(TAG_NAME)?;
    Some(Continue)
}

pub fn script_tag(p: &mut Parser) -> Option<Continue> {
    if !(p.at_keyword("script")) {
        p.error("expected to be at keyword 'script'")?;
    }
    p.expect(TAG_NAME)?;
    Some(Continue)
}

pub fn style_tag(p: &mut Parser) -> Option<Continue> {
    if !(p.at_keyword("style")) {
        p.error("expected to be at keyword 'style'")?;
    }
    p.expect(TAG_NAME)?;
    Some(Continue)
}

pub fn template_content(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&tokenset![TEXT, WHITESPACE]) {
        html_chardata(p)?;
    }
    while p.at_ts(&tokenset![COMMENT, L_ANGLE, MUSTACHE]) {
        if p.at(L_ANGLE) {
            element(p)?;
        } else if p.at(MUSTACHE) {
            p.bump();
        } else if p.at(COMMENT) {
            p.bump();
        }
        if p.at_ts(&tokenset![TEXT, WHITESPACE]) {
            html_chardata(p)?;
        }
    }
    Some(Continue)
}

pub fn html_content(p: &mut Parser) -> Option<Continue> {
    if p.at_ts(&tokenset![COMMENT, L_ANGLE, MUSTACHE, TEXT, WHITESPACE]) {
        if p.at_ts(&tokenset![TEXT, WHITESPACE]) {
            html_chardata(p)?;
        }
        while p.at_ts(&tokenset![COMMENT, L_ANGLE, MUSTACHE]) {
            if p.at(L_ANGLE) {
                element(p)?;
            } else if p.at(MUSTACHE) {
                p.bump();
            } else if p.at(COMMENT) {
                p.bump();
            }
            if p.at_ts(&tokenset![TEXT, WHITESPACE]) {
                html_chardata(p)?;
            }
        }
    } else if p.at(SCRIPT_CONTENT) {
        if p.at(SCRIPT_CONTENT) {
            script_block(p)?;
        }
    } else if p.at(STYLE_CONTENT) {
        if p.at(STYLE_CONTENT) {
            style_block(p)?;
        }
    }
    Some(Continue)
}

pub fn attribute(p: &mut Parser) -> Option<Continue> {
    if (p.at(COLON) || (p.at_keyword("v-bind") && p.at(TAG_NAME))) && {
        // try --> ({ <predicate> }? TAG_NAME)? : attribute_key (attribute_modifier)* ((WS)? = (WS)? attribute_value)? #ATTRIBUTE_BINDING
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            let _marker = p.start();
            let _ok = catch!({
                if p.at_keyword("v-bind") && p.at(TAG_NAME) {
                    p.bump();
                }
                p.expect(COLON)?;
                attribute_key(p)?;
                while p.at(DOT) {
                    attribute_modifier(p)?;
                }
                if p.at_ts(&tokenset![EQ, WS]) {
                    let mut _checkpoint = p.checkpoint(true);
                    catch!({
                        p.eat(WS);
                        p.expect(EQ)?;
                        p.eat(WS);
                        attribute_value(p)?;
                        Some(Continue)
                    });
                    p.commit(_checkpoint)?.ok();
                }
                Some(Continue)
            });
            p.complete(_marker, ATTRIBUTE_BINDING);
            if _ok.is_none() {
                return None;
            }
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if (p.at(AT) || (p.at_keyword("v-on") && p.at(TAG_NAME))) && {
        // try --> ({ <predicate> }? TAG_NAME | @) attribute_key (attribute_modifier)* ((WS)? = (WS)? attribute_value)? #ATTRIBUTE_LISTENER
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            let _marker = p.start();
            let _ok = catch!({
                if p.at_keyword("v-on") && p.at(TAG_NAME) {
                    p.bump();
                } else if p.at(AT) {
                    p.bump();
                }
                attribute_key(p)?;
                while p.at(DOT) {
                    attribute_modifier(p)?;
                }
                if p.at_ts(&tokenset![EQ, WS]) {
                    let mut _checkpoint = p.checkpoint(true);
                    catch!({
                        p.eat(WS);
                        p.expect(EQ)?;
                        p.eat(WS);
                        attribute_value(p)?;
                        Some(Continue)
                    });
                    p.commit(_checkpoint)?.ok();
                }
                Some(Continue)
            });
            p.complete(_marker, ATTRIBUTE_LISTENER);
            if _ok.is_none() {
                return None;
            }
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(TAG_NAME) && {
        // try --> TAG_NAME (WS)? = (WS)? attribute_value #ATTRIBUTE
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            let _marker = p.start();
            let _ok = catch!({
                p.bump();
                p.eat(WS);
                p.expect(EQ)?;
                p.eat(WS);
                attribute_value(p)?;
                Some(Continue)
            });
            p.complete(_marker, ATTRIBUTE);
            if _ok.is_none() {
                return None;
            }
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(TAG_NAME) {
        let _marker = p.start();
        p.bump();
        p.complete(_marker, ATTRIBUTE);
    } else {
        // otherwise, emit an error
        p.expected_ts_in("attribute", &tokenset![AT, COLON, TAG_NAME])?;
    }
    Some(Continue)
}

pub fn attribute_modifier(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = catch!({
        p.expect(DOT)?;
        p.expect(TAG_NAME)?;
        Some(Continue)
    });
    p.complete(_marker, ATTRIBUTE_MODIFIER);
    _ok
}

pub fn attribute_key(p: &mut Parser) -> Option<Continue> {
    if p.at(L_SQUARE) {
        let _marker = p.start();
        let _ok = catch!({
            p.bump();
            p.eat(WS);
            p.expect(TAG_NAME)?;
            p.eat(WS);
            p.expect(R_SQUARE)?;
            Some(Continue)
        });
        p.complete(_marker, ATTRIBUTE_KEY);
        if _ok.is_none() {
            return None;
        }
    } else if p.at(TAG_NAME) {
        let _marker = p.start();
        p.bump();
        p.complete(_marker, ATTRIBUTE_KEY);
    } else {
        p.expected_ts_in("attribute_key", &tokenset![L_SQUARE, TAG_NAME])?;
    }
    Some(Continue)
}

pub fn element(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = element_pattern(p);
    p.complete(_marker, ELEMENT);
    _ok
}

pub fn element_pattern(p: &mut Parser) -> Option<Continue> {
    p.expect(L_ANGLE)?;
    if ((p.at_keyword("area") || p.at_keyword("base") || p.at_keyword("br") || p.at_keyword("col") || p.at_keyword("embed") || p.at_keyword("hr") || p.at_keyword("img") || p.at_keyword("input") || p.at_keyword("link") || p.at_keyword("meta") || p.at_keyword("param") || p.at_keyword("source") || p.at_keyword("track") || p.at_keyword("wbr")) && p.at(TAG_NAME)) && {
        // try --> empty_element_tag_name (WS)? (attribute (WS)?)* (> | />)
        let mut _checkpoint = p.checkpoint(true);
        catch!({
            empty_element_tag_name(p)?;
            p.eat(WS);
            while p.at_ts(&tokenset![AT, COLON, TAG_NAME]) {
                attribute(p)?;
                p.eat(WS);
            }
            p.expect_ts(&tokenset![R_ANGLE, SLASH_R_ANGLE])?;
            Some(Continue)
        });
        p.commit(_checkpoint)?.is_ok()
    } {
        // ok
    } else if p.at(TAG_NAME) {
        p.bump();
        p.eat(WS);
        while p.at_ts(&tokenset![AT, COLON, TAG_NAME]) {
            attribute(p)?;
            p.eat(WS);
        }
        if p.at(SLASH_R_ANGLE) {
            p.bump();
        } else if p.at(R_ANGLE) {
            p.bump();
            html_content(p)?;
            if p.at(L_ANGLE) {
                p.bump();
                p.expect(SLASH)?;
            } else if p.at(L_ANGLE_SLASH) {
                p.bump();
            } else {
                p.expected_ts_in("element_pattern", &tokenset![L_ANGLE, L_ANGLE_SLASH])?;
            }
            p.eat(WS);
            p.expect(TAG_NAME)?;
            p.eat(WS);
            p.expect(R_ANGLE)?;
        } else {
            p.expected_ts_in("element_pattern", &tokenset![R_ANGLE, SLASH_R_ANGLE])?;
        }
    } else {
        // otherwise, emit an error
        p.expected_in("element_pattern", TAG_NAME)?;
    }
    Some(Continue)
}

pub fn empty_element_tag_name(p: &mut Parser) -> Option<Continue> {
    if p.at_keyword("area") && p.at(TAG_NAME) {
        p.bump();
    } else if p.at_keyword("base") && p.at(TAG_NAME) {
        p.bump();
    } else if p.at_keyword("br") && p.at(TAG_NAME) {
        p.bump();
    } else if p.at_keyword("col") && p.at(TAG_NAME) {
        p.bump();
    } else if p.at_keyword("embed") && p.at(TAG_NAME) {
        p.bump();
    } else if p.at_keyword("hr") && p.at(TAG_NAME) {
        p.bump();
    } else if p.at_keyword("img") && p.at(TAG_NAME) {
        p.bump();
    } else if p.at_keyword("input") && p.at(TAG_NAME) {
        p.bump();
    } else if p.at_keyword("link") && p.at(TAG_NAME) {
        p.bump();
    } else if p.at_keyword("meta") && p.at(TAG_NAME) {
        p.bump();
    } else if p.at_keyword("param") && p.at(TAG_NAME) {
        p.bump();
    } else if p.at_keyword("source") && p.at(TAG_NAME) {
        p.bump();
    } else if p.at_keyword("track") && p.at(TAG_NAME) {
        p.bump();
    } else if p.at_keyword("wbr") && p.at(TAG_NAME) {
        p.bump();
    } else {
        // otherwise, emit an error
        p.expected_in("empty_element_tag_name", TAG_NAME)?;
    }
    Some(Continue)
}

pub fn attribute_value(p: &mut Parser) -> Option<Continue> {
    p.expect_ts(&tokenset![QUOTED, TAG_NAME])
}

pub fn html_chardata(p: &mut Parser) -> Option<Continue> {
    p.expect_ts(&tokenset![TEXT, WHITESPACE])
}

pub fn html_misc(p: &mut Parser) -> Option<Continue> {
    p.expect_ts(&tokenset![COMMENT, TEXT, WHITESPACE])
}

pub fn script_block(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = p.expect(SCRIPT_CONTENT);
    p.complete(_marker, SCRIPT_BLOCK);
    _ok
}

pub fn style_block(p: &mut Parser) -> Option<Continue> {
    let _marker = p.start();
    let _ok = p.expect(STYLE_CONTENT);
    p.complete(_marker, STYLE_BLOCK);
    _ok
}
